<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-27T15:48:28+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Study &amp;amp; Store</title><subtitle>tinygun&apos;s blog</subtitle><entry><title type="html">1장 - Docker 설치</title><link href="http://localhost:4000/docker_1/" rel="alternate" type="text/html" title="1장 - Docker 설치" /><published>2022-10-27T15:00:00+09:00</published><updated>2022-10-27T15:00:00+09:00</updated><id>http://localhost:4000/docker_1</id><content type="html" xml:base="http://localhost:4000/docker_1/"><![CDATA[<p>※ 이 글은 <a href="https://wikibook.co.kr/docker-kube/">시작하세요! 도커/쿠버네티스(2020)</a> 책의 1장을 개인적으로 정리하고 잡다한 것들을 추가한 글입니다.<br /></p>

<p>※ 예제코드는 <a href="https://wikibook.co.kr/docker-kube/">위키북스 링크</a>에서 확인할 수 있습니다.</p>

<p><br /></p>

<h2 id="1-들어가면서">1. 들어가면서</h2>

<p>어떤 프로그램이든 설치하려면 시스템 호환, 의존성 등이 문제가 된다.<br />이것들이 다 충족되어도 버전관리 및 배포할 때마다 힘들다.<br />과거에는 VMWare 등 가상 머신을 사용했지만, 항상 시스템 자원을 일정량 소모하는 단점이 있다.</p>

<p>이러한 문제점을 해결한 것이 프로세스 단위로 실행되는 컨테이너 개념이다.<br />가장 대표적인 것이 <strong>Docker</strong>다.</p>

<p>도커는 리눅스 환경에 가장 최적화되어있지만, 나는 윈도우를 사용중이므로 WSL2 우분투를 사용할 것이다.<br />WSL는 자연어 처리할 때 mecab이 안돌아가던가 하는 문제가 있던 것으로 기억한다.<br />완전한 리눅스 환경을 구축한 것은 아니니, 테스트용이 아니라면 리눅스 따로 설치하는 것이 좋다.<br />WSL2에서 문제가 해결됐는지 몰라도, 도커 테스트용으로는 충분하므로 넘어가도록 한다.<br />리눅스 설치를 위한 포스트가 아니므로 필요하다면 <a href="https://gaesae.com/161">참조</a>위치 남겨둔 것으로 대체한다.</p>

<p>프로그램을 도커로 운영할 일이 생겨서 학습차원으로 포스트 작성하게 되었다.<br />우분투 서버 환경에서 운영하기 때문에, GUI 툴을 사용하지 않고 커맨드 위주로 작성할 것이다.</p>

<p><strong>환경</strong>: Windows 10, WSL2 Ubuntu 20.04.5 LTS</p>

<hr />

<p><br /></p>

<h2 id="2-docker설치">2. Docker설치</h2>

<p>책이나 블로그에 많이들 적어놨지만, 오류 발생하는 경우가 많다.<br /><a href="https://docs.docker.com/engine/install/ubuntu/">공식 홈페이지</a> 들어가서 설치 당일에도 되는 명령어를 적어두자.<br />2022.10.27 기준 다음과 같다.</p>

<ul>
  <li>(기존에 설치한 경우) 이전 버전 삭제</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt-get remove docker docker-engine docker.io containerd runc
</code></pre></div></div>

<ul>
  <li>관련 패키지 설치</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt-get update
<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="se">\</span>
    ca-certificates <span class="se">\</span>
    curl <span class="se">\</span>
    gnupg <span class="se">\</span>
    lsb-release
</code></pre></div></div>

<ul>
  <li>도커 공식 gpg 키 등록</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/apt/keyrings
<span class="nv">$ </span>curl <span class="nt">-fsSL</span> https://download.docker.com/linux/ubuntu/gpg | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /etc/apt/keyrings/docker.gpg
</code></pre></div></div>

<ul>
  <li>저장소 세팅</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="se">\</span>
  <span class="s2">"deb [arch=</span><span class="si">$(</span>dpkg <span class="nt">--print-architecture</span><span class="si">)</span><span class="s2"> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu </span><span class="se">\</span><span class="s2">
  </span><span class="si">$(</span>lsb_release <span class="nt">-cs</span><span class="si">)</span><span class="s2"> stable"</span> | <span class="nb">sudo tee</span> /etc/apt/sources.list.d/docker.list <span class="o">&gt;</span> /dev/null
</code></pre></div></div>

<ul>
  <li>도커 설치</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt-get update
<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>docker-ce docker-ce-cli containerd.io docker-compose-plugin
</code></pre></div></div>

<ul>
  <li>서비스 실행 및 버전 확인</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>service docker start
<span class="nv">$ </span>docker <span class="nt">-v</span>
</code></pre></div></div>

<p>WSL2 에서 sytemtctl 사용하려면 따로 설치하는 과정들이 있어서 sevice 명령으로 진행했다.<br />32비트, 구형 윈도우 등 구버전 환경만 아니라면 잘 돌아갈 것이다.<br /><del>애초에 WSL2 필요사양조차 충족하지 못했을 것</del></p>

<hr />

<p><br /></p>

<h2 id="3-기타-방법">3. 기타 방법</h2>

<p>우분투 CLI 환경 외, 사용할 수 있는 방법은 다음과 같다.</p>

<ul>
  <li>Docker Toolbox
    <ul>
      <li>가상 머신을 생성해 그 내부에 도커 설치</li>
      <li>외부 접근 시, 호스트-가상머신 사이에 포트 포워딩 별도로 필요</li>
    </ul>
  </li>
  <li>Docker for Windows/Mac
    <ul>
      <li>Linuxkit 사용하여 호스트 자체에 가상화 기술 적용
        <ul>
          <li>Windows: Hyper-V</li>
          <li>Mac: whyve</li>
        </ul>
      </li>
      <li>호스트의 포트포워딩 설정만으로 외부 접근 용이</li>
    </ul>
  </li>
  <li>별도 Linux 환경
    <ul>
      <li>VirtualBox/VmWare
        <ul>
          <li>별도의 시스템 자원 소요.</li>
        </ul>
      </li>
      <li>AWS EC2
        <ul>
          <li>클라우드 환경에서 제공받는 리눅스 환경</li>
        </ul>
      </li>
      <li><strong>WSL</strong></li>
    </ul>
  </li>
</ul>

<hr />

<p><br /></p>

<h4 id="참고">참고</h4>

<ul>
  <li><a href="https://wikibook.co.kr/docker-kube/">시작하세요! 도커/쿠버네티스(2020)</a></li>
</ul>]]></content><author><name></name></author><category term="docker" /><category term="docker" /><category term="install" /><summary type="html"><![CDATA[WSL2 Ubuntu 20.04 환경에서 Docker 설치]]></summary></entry><entry><title type="html">NLP_한국어 임베딩(2019) 3장 정리</title><link href="http://localhost:4000/nlp_preprocessing/" rel="alternate" type="text/html" title="NLP_한국어 임베딩(2019) 3장 정리" /><published>2020-02-02T18:00:00+09:00</published><updated>2020-02-02T18:00:00+09:00</updated><id>http://localhost:4000/nlp_preprocessing</id><content type="html" xml:base="http://localhost:4000/nlp_preprocessing/"><![CDATA[<hr />

<p>※ 이 글은 <a href="http://acornpub.co.kr/book/korean-embedding">한국어 임베딩(2019)</a> 책을 개인적으로 정리하고 잡다한 것들을 추가한 글입니다.<br />원문과 똑같은 부분은… 이해를 못해서 그대로 쓴 부분입니다.</p>

<p>※ 책은 <a href="https://github.com/ratsgo/embedding">깃허브</a>에 있는 소스들을 사용하고 있습니다. 셸을 사용하는 경우 여기 있는 파일들을 돌리는 겁니다.</p>

<p><br /></p>

<h2 id="1-데이터-확보">1. 데이터 확보</h2>

<p>책에서는 다음과 같은 오픈 소스를 알려주고 있다.</p>

<ul>
  <li>한국어 위키백과</li>
  <li>KorQuAD</li>
  <li>네이버 영화 리뷰 말뭉치</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">preprocess.sh</code> 파일이 제공되어 편하게 데이터를 추출할 수 있다.<br />다운로드, 각종 전처리 등 여러 커맨드가 들어있다.<br />나는 빨리 다뤄보고 싶은 자료들이 있어서 텍스트 추출은 넘어가려고 한다.</p>

<p>마침 전처리 완료된 데이터 다운로드도 제공하고 있기 때문에,<br />우분투에서 이것만 실행하고 마칠 것이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash preprocess.sh dump-processed
</code></pre></div></div>

<p><br /></p>

<hr />

<h2 id="2-지도-학습-기반-형태소-분석">2. 지도 학습 기반 형태소 분석</h2>

<p>좋은 임베딩을 만드려면 문장, 단어의 경계를 알려줘야 한다.<br />그렇지 않으면 어휘 집합에 속한 단어 수가 기하급수적으로 늘어나고, 처리속도 역시 떨어진다.<br />특히, 한국어는 어미, 조사가 발달한 <strong>교착어(agglutinative language)</strong>이기 때문에 섬세함이 필요하다.</p>

<p><code class="language-plaintext highlighter-rouge">가다</code>를 예시로 들어보자.<br /><code class="language-plaintext highlighter-rouge">가다</code>는 문맥에 따라 <code class="language-plaintext highlighter-rouge">가다</code>, <code class="language-plaintext highlighter-rouge">가겠다</code>, <code class="language-plaintext highlighter-rouge">가더라</code>, <code class="language-plaintext highlighter-rouge">가겠더라</code> 등으로 쓸 수 있다.<br />예시만 따져봐도 <code class="language-plaintext highlighter-rouge">가다</code>라는 의미를 가진 단어가 4개나 된다.<br />이런 중복을 줄이기 위해 형태소 분석이 필요하다.</p>

<p>위에 제시한 단어들을 <code class="language-plaintext highlighter-rouge">konlpy</code>의 <code class="language-plaintext highlighter-rouge">Mecab</code> 기준으로 분석하면,<br /><code class="language-plaintext highlighter-rouge">가</code>,<code class="language-plaintext highlighter-rouge">겠</code>,<code class="language-plaintext highlighter-rouge">다</code>,<code class="language-plaintext highlighter-rouge">더라</code> 등 4개의 형태소가 나온다.<br />만약 <code class="language-plaintext highlighter-rouge">오다</code>, <code class="language-plaintext highlighter-rouge">오겠다</code>, <code class="language-plaintext highlighter-rouge">오더라</code>, <code class="language-plaintext highlighter-rouge">오겠더라</code>라는 단어가 등장했을 때, 원래라면 4개 단어가 늘어날 것이다.<br />하지만 형태소 분석기를 사용하면 <code class="language-plaintext highlighter-rouge">오</code>라는 형태소만 추가하면 된다.<br />데이터가 적게 늘어나니까 데이터 연산처리 또한 효율적이다.</p>

<p>교착어인 한국어는 한정된 종류의 조사와 어미를 자주 이용한다.<br />때문에 각각에 대응하는 명사, 용언(형용사, 둉사) 어간만 어휘 집합에 추가하면 단어 숫자를 많이 줄일 수 있다.</p>

<p><strong>(1) KoNLPy</strong></p>

<p><a href="http://konlpy.org/ko/latest/">KoNLPy</a>는 오픈소스 형태소 분석기를 <strong>파이썬</strong>에서 사용할 수 있도록 인터페이스를 통일한 패키지다.<br />당연히 파이썬 환경에서 사용하도록 한다.</p>

<p><code class="language-plaintext highlighter-rouge">Mecab</code>, <code class="language-plaintext highlighter-rouge">Okt</code>, <code class="language-plaintext highlighter-rouge">Komoran</code>, <code class="language-plaintext highlighter-rouge">Hannanum</code>, <code class="language-plaintext highlighter-rouge">Kkma</code> 등 총 5가지 분석기가 있다.<br />(<a href="http://eunjeon.blogspot.com/">은전한닢</a>, <a href="https://github.com/twitter/twitter-korean-text">Okt</a>(트위터), <a href="https://www.shineware.co.kr/products/komoran/">코모란</a>, <a href="https://kldp.net/hannanum/">한나눔</a>, <a href="http://kkma.snu.ac.kr/documents/">꼬꼬마</a> 분석기라는군요.)</p>

<p>형태소 분석과 품사 분석은 아래와 같이 할 수 있다.<br /><u>※ Mecab은 윈도우에서 사용 불가능합니다.</u></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">konlpy.tag</span> <span class="kn">import</span> <span class="n">Mecab</span><span class="p">,</span> <span class="n">Okt</span><span class="p">,</span> <span class="n">Komoran</span><span class="p">,</span> <span class="n">Hannanum</span><span class="p">,</span> <span class="n">Kkma</span>
<span class="n">tn</span> <span class="o">=</span> <span class="n">Mecab</span><span class="p">()</span> <span class="c1"># 다른 분석기를 사용하려면 Okt() 등을 사용하면 됩니다.
</span><span class="k">print</span><span class="p">(</span><span class="n">tn</span><span class="p">.</span><span class="n">morphs</span><span class="p">(</span><span class="s">"아버지가방에들어가신다"</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">tn</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="s">"아버지가방에들어가신다"</span><span class="p">))</span>
</code></pre></div></div>

<p>결과물은 다음과 같다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['아버지', '가', '방', '에', '들어가', '신다']
[('아버지', 'NNG'), ('가', 'JKS'), ('방', 'NNG'), ('에', 'JKB'), ('들어가', 'VV'), ('신다', 'EP+EC')]
</code></pre></div></div>

<p><a href="http://konlpy.org/ko/latest/morph/#comparison-between-pos-tagging-classes">konlpy 설명 문서</a>에 의하면, 형태소 분석기별 속도는 다음과 같다.</p>

<table>
  <thead>
    <tr>
      <th>분석기명</th>
      <th>로딩 시간</th>
      <th>실행 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Kkma</td>
      <td>5.6988</td>
      <td>35.7163</td>
    </tr>
    <tr>
      <td>Komoran</td>
      <td>5.4866</td>
      <td>25.6008</td>
    </tr>
    <tr>
      <td>Hannanum</td>
      <td>0.6591</td>
      <td>8.8251</td>
    </tr>
    <tr>
      <td>Okt(Twitter)</td>
      <td>1.4870</td>
      <td>2.4714</td>
    </tr>
    <tr>
      <td>Mecab</td>
      <td>0.0007</td>
      <td>0.2838</td>
    </tr>
  </tbody>
</table>

<p>한국어 임베딩 저자의 <a href="[https://ratsgo.github.io/from%20frequency%20to%20semantics/2017/05/10/postag/](https://ratsgo.github.io/from frequency to semantics/2017/05/10/postag/)">포스팅</a>을 살펴보니, 품사 태그 정보가 속도에 영향을 미치는 듯하다.</p>

<p>성능 분석도 참조하면서 골라서 쓰는 것이 좋겠다.<br />(성능 역시 <a href="http://konlpy.org/ko/latest/morph/#comparison-between-pos-tagging-classes">konlpy 설명 문서</a>에 있으니 참조하자.)<br />Mecab이 월등한 속도에 성능도 적절해서 현업에서 많이 쓴다고 한다.</p>

<p><strong>(2) Khaiii</strong></p>

<p><a href="https://tech.kakao.com/2018/12/13/khaiii/">Khaiii</a>(Kakao Hangul Analyzer III)는 카카오에서 만든 한국어 형태소 분석기다.<br />세종코퍼스를 이용해 CNN모델 적용해 학습했다고 한다.<br />GPU 없이 형태소 분석 가능하고 속도 역시 빠르다고 한다.</p>

<p><u>※ Khaii 역시 윈도우에서 사용 불가능합니다.</u></p>

<p>설치는 음… 좀 귀찮아보인다.<br />C++ 기반이라 파이썬과 연동하기 전에 여러 과정이 필요하다.<br />설치는 <a href="https://github.com/kakao/khaiii/wiki/빌드-및-설치">공식 문서</a>를 참고하자. <br />(애초에 난 컴퓨터를 잘 모른다…하라는대로 했더니 되긴 했다.)</p>

<p>좀 막힌 부분들이 있어서 내가 거친 과정을 적어둔다.<br />나는 환경이 꼬여서 sudo는 안되고 root에서 하니까 됐다.<br />git을 sudo로 해서 파일들 권한이 root로 설정되서 그런가 생각한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 빌드</span>
pip <span class="nb">install </span>cmake
git clone https://github.com/kakao/khaiii
<span class="nb">cd </span>khaiii
<span class="nb">mkdir </span>build
<span class="nb">cd </span>build
cmake ..
make all
make resource
<span class="c"># 설치</span>
make <span class="nb">install
</span>make package_python
<span class="nb">cd </span>package_python
pip <span class="nb">install</span> <span class="nb">.</span>
</code></pre></div></div>

<p>이제 파이썬에서 아래 코드가 들어먹는지 확인하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">khaiii</span> <span class="kn">import</span> <span class="n">KhaiiiApi</span>
<span class="n">tn</span> <span class="o">=</span> <span class="n">KhaiiiApi</span><span class="p">()</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">tn</span><span class="p">.</span><span class="n">analyze</span><span class="p">(</span><span class="s">'안녕, 세상.'</span><span class="p">)</span>
<span class="n">token1</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">token2</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">print</span><span class="p">(</span><span class="s">"기본출력:"</span><span class="p">,[</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span> <span class="c1"># 기본 출력 데이터
</span><span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">token1</span><span class="p">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">"/"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">word</span><span class="p">.</span><span class="n">morphs</span><span class="p">])</span>
    <span class="n">token2</span><span class="p">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">word</span><span class="p">.</span><span class="n">morphs</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">"글자출력:"</span><span class="p">,</span><span class="n">token1</span><span class="p">)</span> <span class="c1"># 글자만 출력
</span><span class="k">print</span><span class="p">(</span><span class="s">"품사출력:"</span><span class="p">,</span><span class="n">token2</span><span class="p">)</span> <span class="c1"># 품사도 출력
</span></code></pre></div></div>

<p>결과물은 다음과 같다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>기본출력: ['안녕,<span class="se">\t</span>안녕/IC + ,/SP', '세상.<span class="se">\t</span>세상/NNG + ./SF']
글자출력: ['안녕', ',', '세상', '.']
품사출력: ['안녕/IC', ',/SP', '세상/NNG', './SF']
</code></pre></div></div>

<p>konlpy에 담긴 5개 분석기와 khaiii를 <a href="[https://iostream.tistory.com/144?utm_source=gaerae.com&amp;utm_campaign=%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%8A%A4%EB%9F%BD%EB%8B%A4&amp;utm_medium=social&amp;fbclid=IwAR2A87bBOU93ePHgdLsGeAal-2iLszDJzPJl1_IuYeHcd8RoNd8Cd6f054g](https://iostream.tistory.com/144?utm_source=gaerae.com&amp;utm_campaign=개발자스럽다&amp;utm_medium=social&amp;fbclid=IwAR2A87bBOU93ePHgdLsGeAal-2iLszDJzPJl1_IuYeHcd8RoNd8Cd6f054g)">같이 비교한 문서</a>가 있다.<br />요약하자면, 여전히 <code class="language-plaintext highlighter-rouge">Mecab</code>이 제일 빠르고 품질도 상위권이다.</p>

<p><strong>(3) Mecab 사용자 사전 등록</strong></p>

<p>분석을 하다 보면 사용자 사전이 필요할 때가 있다.<br />조선왕조실록을 예시로 들고자 한다.<br /><a href="http://sillok.history.go.kr/id/kaa_10409108_001">태조실록</a>에 <u>"오도리(吾都里) 상만호 동맹가첩목아(童猛哥帖木兒) 등 5인이 와서 토산물을 바쳤다."</u>는 내용이 있다.<br />이를 분석하면 다음과 같이 나온다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="s">'오도리'</span><span class="p">,</span> <span class="s">'('</span><span class="p">,</span> <span class="s">'吾'</span><span class="p">,</span> <span class="s">'都'</span><span class="p">,</span> <span class="s">'里'</span><span class="p">,</span> <span class="s">')'</span><span class="p">,</span> <span class="s">'상만호'</span><span class="p">,</span> <span class="s">'동맹가'</span><span class="p">,</span> <span class="s">'첩목아'</span><span class="p">,</span> <span class="s">'('</span><span class="p">,</span> <span class="s">'童'</span><span class="p">,</span> <span class="s">'猛'</span><span class="p">,</span> <span class="s">'哥'</span><span class="p">,</span> <span class="s">'帖木兒'</span><span class="p">,</span> <span class="s">')'</span><span class="p">,</span> <span class="s">'등'</span><span class="p">,</span> <span class="s">'5'</span><span class="p">,</span> <span class="s">'인'</span><span class="p">,</span> <span class="s">'이'</span><span class="p">,</span> <span class="s">'와서'</span><span class="p">,</span> <span class="s">'토산물'</span><span class="p">,</span> <span class="s">'을'</span><span class="p">,</span> <span class="s">'바쳤'</span><span class="p">,</span> <span class="s">'다'</span><span class="p">,</span> <span class="s">'.'</span><span class="p">]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">동맹가첩목아</code>는 사람 이름인데 분석기는 <code class="language-plaintext highlighter-rouge">동맹가</code>,<code class="language-plaintext highlighter-rouge">첩목아</code>로 토막살인을 저질렀다.<br />이런 참혹한 현장을 막기 위해 사람 이름임을 명시해야 한다.</p>

<p>책에서는 사전을 컴파일할 수 있는 셸 파일을 제공하고 있다.<br />하지만 직접 만들어보고 싶어서 다른 방법을 설명하고자 한다.<br />도커 환경이 아닌 스스로 환경을 구축하면서 공부하는게 좋아서 이런 것도 최대한 직접 하고있다.</p>

<p>우선 user-dic 폴더에 들어간다. (내 경우 /tmp/mecab-ko-dic-2.1.1-20180720/user-dic 였다.)<br /><a href="https://bitbucket.org/eunjeon/mecab-ko-dic/src/df15a487444d88565ea18f8250330276497cc9b9/final/user-dic/">공식 홈피</a>에 사용법이 나와있다.<br />place.csv, person.csv 등의 예시 파일이 있는데, 대략 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># nnp.csv
</span><span class="n">대우</span><span class="p">,,,,</span><span class="n">NNP</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">대우</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span>
<span class="n">구글</span><span class="p">,,,,</span><span class="n">NNP</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">구글</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span>
<span class="c1"># person.csv
</span><span class="n">까비</span><span class="p">,,,,</span><span class="n">NNP</span><span class="p">,</span><span class="n">인명</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">까비</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span>
<span class="c1"># place.csv
</span><span class="n">세종</span><span class="p">,,,,</span><span class="n">NNP</span><span class="p">,</span><span class="n">지명</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">세종</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span>
<span class="n">세종시</span><span class="p">,,,,</span><span class="n">NNP</span><span class="p">,</span><span class="n">지명</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">세종시</span><span class="p">,</span><span class="n">Compound</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="n">세종</span><span class="o">/</span><span class="n">NNP</span><span class="o">/</span><span class="n">지명</span><span class="o">+</span><span class="n">시</span><span class="o">/</span><span class="n">NNG</span><span class="o">/*</span> <span class="c1">#..뭐지
</span></code></pre></div></div>

<p>자료구조는 다음과 같다고 한다.</p>

<ul>
  <li>표층형/0/0/0/품사태그/의미분류/종성유무/읽기/타입/첫번째품사/마지막품사/표현</li>
</ul>

<p>여기에 사용자 사전 csv 파일을 만들면 된다.<br />이름을 뭘로 정하든 csv이고, 위와 같은 양식으로 작성하면 상관없다.<br />난 귀찮아서… person.csv를 다음과 같이 수정하고 진행할 것이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>동맹가첩목아,,,,NNP,인명,F,동맹가첩목아,*,*,*,*
</code></pre></div></div>

<p>사전에 내용을 변경했다면, 이제 변경한 내용을 적용시킬 차례다.<br />user-dic 상위폴더(본인의 경우 mecab-ko-dic-2.1.1-20180720)으로 나오면 tools 디렉토리에 <code class="language-plaintext highlighter-rouge">add-userdic.sh</code>파일이 있다.<br />이 파일을 실행하면 사전이 컴파일되는데… 나는 약간 문제가 있었다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. user-dic, tools 등 하위폴더에서 add-userdic.sh 실행</span>
../tools/add-userdic.sh
<span class="c"># 2. 상위폴더(mecab-ko-dic-2.1.1-20180720)에서 add-userdic.sh 실행</span>
tools/add-userdic.sh
</code></pre></div></div>

<p>위 과정을 거친 후 <code class="language-plaintext highlighter-rouge">make install</code>을 실행하면 사전이 설치되어야 정상이다.<br />하지만 1번 과정대로 하면 <code class="language-plaintext highlighter-rouge">make: *** No rule to make target 'install'.  Stop.</code>라는 오류가 떴다.<br />2번 과정대로 하면 문제가 없이 사전이 적용되었다.<br />위에서도 말했지만, 권한이 꼬여서 그런거 같다.</p>

<p>어쨌든 우여곡절 끝에 모든 과정을 마친 후 얻은 결과는 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="s">'오도리'</span><span class="p">,</span> <span class="s">'('</span><span class="p">,</span> <span class="s">'吾'</span><span class="p">,</span> <span class="s">'都'</span><span class="p">,</span> <span class="s">'里'</span><span class="p">,</span> <span class="s">')'</span><span class="p">,</span> <span class="s">'상만호'</span><span class="p">,</span> <span class="s">'동맹가첩목아'</span><span class="p">,</span> <span class="s">'('</span><span class="p">,</span> <span class="s">'童'</span><span class="p">,</span> <span class="s">'猛'</span><span class="p">,</span> <span class="s">'哥'</span><span class="p">,</span> <span class="s">'帖木兒'</span><span class="p">,</span> <span class="s">')'</span><span class="p">,</span> <span class="s">'등'</span><span class="p">,</span> <span class="s">'5'</span><span class="p">,</span> <span class="s">'인'</span><span class="p">,</span> <span class="s">'이'</span><span class="p">,</span> <span class="s">'와서'</span><span class="p">,</span> <span class="s">'토산물'</span><span class="p">,</span> <span class="s">'을'</span><span class="p">,</span> <span class="s">'바쳤'</span><span class="p">,</span> <span class="s">'다'</span><span class="p">,</span> <span class="s">'.'</span><span class="p">]</span>
</code></pre></div></div>

<p>아까 <code class="language-plaintext highlighter-rouge">동맹가</code>, <code class="language-plaintext highlighter-rouge">목첩아</code>로 분리된 이름이 <code class="language-plaintext highlighter-rouge">동맹가첩목아</code>로 이어진 모습을 볼 수 있다.<br />물론 한자 부분은 능지처참되었지만, 붙여주고 싶다면 같은 방식으로 사전에 등록하면 된다.<br />하지만 한자 부분을 붙이는 것이 의미가 있으려면, 한글부분과 한자부분이 동일인임을 증명할 수 있어야 한다.<br /><code class="language-plaintext highlighter-rouge">동맹가첩목아</code>, <code class="language-plaintext highlighter-rouge">童猛哥帖木兒</code>, <code class="language-plaintext highlighter-rouge">동맹가첩목아(童猛哥帖木兒)</code> 모두 동일인임을 증명할 방법이 있다면 셋 다 등록해야겠으나,<br />나는 그런 방법을 알지 못하기 때문에 한글 부분인 <code class="language-plaintext highlighter-rouge">동맹가첩목아</code>만 등록할 것이다.</p>

<p><br /></p>

<hr />

<h2 id="3-비지도-학습-기반-형태소-분석">3. 비지도 학습 기반 형태소 분석</h2>

<p>지도 학습 기법은 형태소 경계나 품사 정보를 모델에 가르쳐준 것이다.<br />여기서 다룰 비지도 학습 기법들은 데이터에 자주 등장하는 단어들을 형태소로 인식하도록 학습한다.</p>

<p><strong>(1) soynlp</strong></p>

<p>(사용하진 않을 예정이라 간단히 정리만 했다.)</p>

<p><a href="https://github.com/lovit/soynlp">soynlp</a>는 파이썬 기반 한국어 자연어 처리 패키지다.<br />비지도 학습 특성상 패턴을 스스로 학습하기 때문에, 어느 정도 규모가 있는 동질적인 문서 집합에서 잘 작동한다.<br />영화 댓글, 특정일자 뉴스 기사 등이 대표적인 사례다.</p>

<p>soynlp의 형태소 분석기는 데이터 통계량에 따른 단어 점수표로 작동한다고 한다.<br /><strong>응집 확률(Cohesion Probability)</strong>, <strong>브랜칭 엔트로피(Branching Entropy)</strong>를 활용한다.<br /><code class="language-plaintext highlighter-rouge">꿀잼 ㅎㅎ</code>, <code class="language-plaintext highlighter-rouge">영화 꿀잼</code>를 예시로 들겠다.<br /><code class="language-plaintext highlighter-rouge">꿀잼</code>은 자주 나타난 단어이며, 이는 <strong>응집확률</strong>이 높다고 판단하여 형태소로 인식된다.<br /><code class="language-plaintext highlighter-rouge">꿀잼</code>의 앞뒤로 <code class="language-plaintext highlighter-rouge">ㅎㅎ</code>, <code class="language-plaintext highlighter-rouge">영화</code> 등 다양한 패턴이 나타났으며, 이는 <strong>브랜칭 엔트로피</strong>가 높다고 판단하여 형태소로 인식된다.</p>

<p>띄어쓰기 교정이 있는게 흥미로운 부분이다.<br />혹시 필요하다면 써보도록 하자.</p>

<p><strong>(2) Google Sentencepiece</strong></p>

<p>센텐스피스(sentencepiece)는 구글(Kudo&amp;Richardson, 2018)에서 공개한 비지도 기반 형태소 분석 패키지다.<br />바이트 페어 인코딩(Bite Pair Encoding, BPE) 등을 지원하며, pip 설치가 가능하다.</p>

<p>BPE는 가장 많이 등장한 문자열을 압축하는 것이다.<br /><code class="language-plaintext highlighter-rouge">aaabdaaabac</code>를 예시로 들어보자.<br /><code class="language-plaintext highlighter-rouge">aa</code>가 많이 나왔고, 이를 <code class="language-plaintext highlighter-rouge">X</code>로 치환하여 <code class="language-plaintext highlighter-rouge">XabdXabac</code>로 만든다.<br /><code class="language-plaintext highlighter-rouge">ab</code>도 많이 나왔고, 이를 <code class="language-plaintext highlighter-rouge">Y</code>로 치환하여 <code class="language-plaintext highlighter-rouge">XYdXYac</code>로 만든다.</p>

<p><strong>BERT</strong> 모델이 BPE로 학습한 어휘 집합을 사용한다.<br />비지도 학습 기법이기 때문에 어떤 언어에든 적용 가능하다.<br />나중에 문장 임베딩에서 다룰 것이기 때문에 이만 마치도록 하겠다.</p>

<p><br /></p>

<hr />

<h2 id="4-주요-내용">4. 주요 내용</h2>

<ul>
  <li>임베딩 학습용 말뭉치는 라인 하나가 문서면 좋다.</li>
  <li>지도 학습 기반의 형태소 분석 모델은 언어학 전문가들이 태깅한 형태소 분석 말뭉치로부터 학습된 기법이다. 사람이 알려준 정답 패턴에 최대한 가깝께 토크나이즈한다. KoNLPy, Khaiii 등이 대표적이다.</li>
  <li>비지도 학습 기반의 형태소 분석 모델은 데이터의 패턴을 모델 스스로 학습하게 함으로써 형태소를 나누는 기법이다. 데이터에 자주 등장하는 단어들을 형태소로 인식한다. soynlp, Google Sentencepiece 등이 대표적이다.</li>
</ul>

<hr />

<p><br /></p>

<h4 id="참고">참고</h4>

<ul>
  <li><a href="http://acornpub.co.kr/book/korean-embedding">한국어 임베딩(2019)</a></li>
</ul>]]></content><author><name></name></author><category term="nlp" /><category term="nlp" /><category term="mecab" /><category term="khaiii" /><category term="konlpy" /><summary type="html"><![CDATA[한국어 데이터의 전처리 과정]]></summary></entry><entry><title type="html">NLP_한국어 임베딩(2019) 2장 정리</title><link href="http://localhost:4000/nlp_vector/" rel="alternate" type="text/html" title="NLP_한국어 임베딩(2019) 2장 정리" /><published>2020-01-29T18:00:00+09:00</published><updated>2020-01-29T18:00:00+09:00</updated><id>http://localhost:4000/nlp_vector</id><content type="html" xml:base="http://localhost:4000/nlp_vector/"><![CDATA[<hr />

<p>※ 이 글은 <a href="http://acornpub.co.kr/book/korean-embedding">한국어 임베딩(2019)</a> 책을 개인적으로 정리하고 잡다한 것들을 추가한 글입니다.<br />원문과 똑같은 부분은… 이해를 못해서 그대로 쓴 부분입니다.</p>

<p>※ 책은 <a href="https://github.com/ratsgo/embedding">깃허브</a>에 있는 소스들을 사용하고 있습니다. 셸을 사용하는 경우 여기 있는 파일들을 돌리는 겁니다.</p>

<p><br /></p>

<h2 id="1-자연어-계산">1. 자연어 계산</h2>

<p>자연어는 사람이 사용하는 언어를 말한다.<br />컴퓨터는 자연어를 사람처럼 이해하지 못한다.<br />단지 계산기일 뿐이기 때문이다.</p>

<p>컴퓨터가 자연어를 처리하기 위해서는 계산할 수 있도록 바꿔줘야 한다.<br />자연어를 계산되는 숫자들로 바꿔주는 과정이 <strong><code class="language-plaintext highlighter-rouge">임베딩(embedding)</code></strong>이다.<br />임베딩 결과 산출된 숫자들의 나열이 <strong><code class="language-plaintext highlighter-rouge">벡터(vector)</code></strong>다.</p>

<p>임베딩 방식을 정리하면 다음과 같다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>bag of words 가정</th>
      <th>언어 모델</th>
      <th>분포 가정</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>내용</td>
      <td>어떤 단어가 (많이) 쓰였나</td>
      <td>단어가 어떤 순서로 쓰였나</td>
      <td>뭔 단어가 같이 쓰였나</td>
    </tr>
    <tr>
      <td>대표 통계량</td>
      <td>TF-IDF</td>
      <td> </td>
      <td>PMI</td>
    </tr>
    <tr>
      <td>대표 모델</td>
      <td>Deep Averaging Network</td>
      <td>ELMo, GPT</td>
      <td>Word2Vec</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<hr />

<h2 id="2-어떤-단어가-많이-쓰였나">2. 어떤 단어가 (많이) 쓰였나</h2>

<p><strong>(1) 백오브워즈(bag of words,  BoW)</strong></p>

<p>백(bag)은 <a href="https://en.wikipedia.org/wiki/Multiset">멀티세트</a>(multiset)를 말한다.<br />멀티세트는 일반적인 세트(set)와 달리 각각 요소에 대해 복수의 인스턴스를 허용하는 개념이다.</p>

<p>집합 \(\{a,a,b,b\}\) 를 예로 들자.<br />세트는 \(\{a,b\}\) 형식으로 표현할 수 있다.<br />멀티세트는 \(\{a^2,b^2\}\) 처럼 표현할 수 있다.<br /><strong>원소마다 몇 개 있는지</strong> 볼 수 있다는 점이 멀티세트의 차별성이다.</p>

<p>파이썬 기준으로는 이렇게 보면 편할 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 세트
</span><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">}</span> <span class="c1"># 일반적인 set와 같다.
# 멀티세트
</span><span class="p">{</span><span class="s">'a'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s">'b'</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span> <span class="c1"># 일반적인 dictionary와 같다.
</span></code></pre></div></div>

<p>세트와 멀티세트는 순서를 고려하지 않는다.<br />파이썬에서 set, dict가 순서를 고려하지 않듯이 말이다.</p>

<p>백오브워즈 임베딩은<br /><code class="language-plaintext highlighter-rouge">저자가 생각한 주제가 문서에서의 단어 사용에 녹아있다</code>는 가정이 깔려있다.<br /><strong>주제</strong>가 비슷한 문서는<br /><strong>단어 등장 여부</strong> 역시 비슷할 것이고,<br /><strong>백오브워즈 임베딩</strong> 역시 유사하다는 입장이다.</p>

<p>다음 백오브워즈 임베딩 표에 의하면<br /><code class="language-plaintext highlighter-rouge">사랑 손님과 어머니</code>, <code class="language-plaintext highlighter-rouge">삼포 가는 길</code> 문서 관련성이 상대적으로 높다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>운수 좋은 날</th>
      <th>사랑 손님과 어머니</th>
      <th>삼포 가는 길</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>기차</td>
      <td>2</td>
      <td>10</td>
      <td>7</td>
    </tr>
    <tr>
      <td>막걸리</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>선술집</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>백오브워즈 임베딩은 간단하긴 하지만, <strong>정보 검색</strong> 분야에서 이걸 가지고 코사인 유사도를 구해 정보를 노출시키는 경우가 많다고 한다.</p>

<p><strong>(2) TF-IDF(Term Frequency-Inverse Document Frequency)</strong></p>

<p>단어 빈도 및 등장여부를 문서 주제파악을 위해 그대로 쓰는 것은 큰 단점이 있다.<br />많이 등장한 단어가 의미있는 단어가 아니기 때문이다.</p>

<p><a href="https://ko.wikipedia.org/wiki/지프의_법칙">지프의 법칙</a>(Zipf’s law)를 예로 들겠다.<br />영어를 기준으로 보면, 단어의 사용빈도는 the, of, and 순이다.<br />우리말로 치면 조사, 대명사가 제일 많이 등장하는 꼴이다.<br />조사나 대명사는 그 자체가 주제를 갖기 어려운 단어다.<br />빈도만으로 문서의 주제를 파악하기 어려운 이유다.</p>

<p><a href="https://ko.wikipedia.org/wiki/Tf-idf">TF-IDF</a>는 그런 단점을 보완한 방법이다.<br />단어 빈도(Term Frequency)와  문서 빈도의 역행렬(Inverse Document Frequency)를 이용한다.<br />TF와 DF를 나눈다는 개념이며, DF를 분모로 사용하기 때문에 IDF라 한다.<br />기본적인 수식은 다음과 같다.
\(TF-IDF(w)=TF(w) \times log(\frac{N}{DF(w)})\)
\(w\)는 단어(word)의 빈도다. \(N\)은 전체 문서의 갯수다.<br />여러가지 TF-IDF가 존재하는데, 위 기본 수식에 가중치를 더한 것들이다.<br />난 저 식의 \(N\)을 \(N+1\)로 바꿀 것이다.<br />특정 단어가 모든 문서에 나온다면 IDF값이 \(log1\)이 되고,<br />\(log1\)은 0이기 때문에 모든 수치를 0으로 만들어버리기 때문이다.<br />문서가 많으면 괜찮을 수 있으나, 예시문에서는 표본이 적어서 의미있는 단어도 날려버린다.</p>

<p>위 백오브워즈 임베딩을 바탕으로 TF_IDF를 구해보자.<br />\(N\)은 3, \(w\)는 아까 백오브워즈 임베딩에 나온 숫자들이다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>운수 좋은 날</th>
      <th>사랑 손님과 어머니</th>
      <th>삼포 가는 길</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>기차</td>
      <td>0.5753641449035617</td>
      <td>2.8768207245178083</td>
      <td>2.013774507162466</td>
    </tr>
    <tr>
      <td>막걸리</td>
      <td>1.3862943611198906</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>선술집</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>백오브워즈 기준으로 <code class="language-plaintext highlighter-rouge">운수 좋은 날</code>의 <code class="language-plaintext highlighter-rouge">기차</code>는 2건, <code class="language-plaintext highlighter-rouge">막걸리</code>는 1건이었다.<br />TF-IDF를 실행한 결과, <code class="language-plaintext highlighter-rouge">운수 좋은 날</code>에서는 1건만 있는 <code class="language-plaintext highlighter-rouge">막걸리</code>가 2건만 있는 <code class="language-plaintext highlighter-rouge">기차</code>보다 높은 가중치를 갖고 있다.<br /><code class="language-plaintext highlighter-rouge">운수 좋은 날</code>의 <code class="language-plaintext highlighter-rouge">기차</code> 값을 구한 식은 다음과 같다.
\(TF(w) \times log(\frac{N+1}{DF(w)})=2 \times log(\frac{3+1}{3})\fallingdotseq0.575\)
패키지 없이 야매로 구한 것이니, TF-IDF가 이런 것이다 수준으로 이해하고 넘어가도록 한다.</p>

<p><strong>(3) Deep Averaging Network</strong></p>

<p>Deep Averaging Network(Iyyer et al., 2015)는 백오브워즈 가정의 뉴럴 네트워크 버전이다.<br /></p>

<figure>
    <center><img src="https://i1.wp.com/mlexplained.com/wp-content/uploads/2018/05/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88-2018-05-10-13.29.52.png?w=366&amp;ssl=1" /></center>
    <figcaption><center><b>Deep Averaging Network</b></center></figcaption>
</figure>

<p>위 사례는 <code class="language-plaintext highlighter-rouge">Predator is a masterpiece</code>라는 문장의 임베딩을 4개의 토큰으로 구분하였다.<br />일반 뉴럴 네트워크와 다른 점은, sequence 데이터로 취급하지 않고 빈도만 따진다는 점이다.<br />이 점에서 백오브워즈와 비슷하다고 한다.</p>

<p>빈도만으로 문장 임베딩을 한 뒤 해당 문서가 어떤 범주인지 분류하는 모델이다.<br />간단한 구조임에도 불구하고 성능이 좋아서 현업에도 자주 쓰인다고 한다.</p>

<p><br /></p>

<hr />

<h2 id="3-단어가-어떤-순서로-쓰였나">3. 단어가 어떤 순서로 쓰였나</h2>

<p><strong>(1) 통계 기반 언어 모델</strong></p>

<p>언어 모델(language model)이란 단어 시퀀스(sequence, 연속적 순서)에 <strong>확률</strong>을 부여하는 모델이다.<br />백오브워즈와 반대로, 단어 등장 순서를 따진다.</p>

<p>통계 기반 언어 모델은 해당 단어 시퀀스가 얼마나 자주 등장하는지 빈도를 세어 학습한다.<br />잘 학습되면 어떤 문장이 그럴 듯한지(확률이 높은지) 알 수 있다.<br />아래와 같이 말이다.</p>

<table>
  <thead>
    <tr>
      <th>문장</th>
      <th>확률</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>진이는 이 책을 세 번 읽었다.</td>
      <td>0.47</td>
    </tr>
    <tr>
      <td>이 책이 진이한테 세 번을 읽혔다.</td>
      <td>0.23</td>
    </tr>
    <tr>
      <td>세 번이 진이한테 이 책을 읽혔다.</td>
      <td>0.07</td>
    </tr>
  </tbody>
</table>

<p>그러나 통계상 한 번도 집계되지 않은(빈도가 없는) 경우는 계산할 수 없다.<br />이를 위해 <strong>n-gram</strong>을 사용한다.</p>

<p>n-gram은 n개 단어를 뜻한다. 예를 들면,<br /><code class="language-plaintext highlighter-rouge">난폭, 운전</code>은 2-gram(bigram), <code class="language-plaintext highlighter-rouge">누명, 을, 쓰다</code>는 3-gram(trigram), <code class="language-plaintext highlighter-rouge">바람, 잘, 날, 없다</code>는 4-gram이다.<br /></p>

<table>
  <thead>
    <tr>
      <th>표현</th>
      <th>빈도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>이제</td>
      <td>112</td>
    </tr>
    <tr>
      <td>식사를</td>
      <td>56</td>
    </tr>
    <tr>
      <td>할</td>
      <td>341</td>
    </tr>
    <tr>
      <td>시간이다</td>
      <td>28</td>
    </tr>
    <tr>
      <td>이제 식사를</td>
      <td>9</td>
    </tr>
    <tr>
      <td>식사를 할</td>
      <td>7</td>
    </tr>
    <tr>
      <td>할 시간이다</td>
      <td>2</td>
    </tr>
    <tr>
      <td>이제 식사를 할 시간이다</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>위 표를 통해 n-gram 사용 예시를 들고자 한다.<br /><code class="language-plaintext highlighter-rouge">이제 식사를 할</code> 다음에 <code class="language-plaintext highlighter-rouge">시간이다</code>가 나타날 확률은 <strong>조건부확률</strong>을 활용해 <strong>최대우도추정법</strong>(Maximum Likelihood Estimation, MLE)로 유도하면 다음과 같다.
\(P(시간이다|이제,식사를,할)=\frac{Freq(이제,식사를,할,시간이다)}{Freq(이제,식사를,할)}=0\)
Freq는 해당 표현 순서가 등장한 빈도(frequency)를 뜻한다.<br /><code class="language-plaintext highlighter-rouge">이제 식사를 할 시간이다</code>가 0건이기 때문에 확률은 0이 된다.<br />딱히 틀린 문장이 아님에도 이런 문장이 나올 확률이 없다고 계산하는 것이다.</p>

<p>여기서 n-gram 모델을 쓰면 이런 문제를 일부 해결할 수 있다.<br />직전 n-1개 단어의 등장 확률로 전체 단어 시퀀스 등장 확률을 근사하는 것이다.<br /><a href="https://ko.wikipedia.org/wiki/%EB%A7%88%EB%A5%B4%EC%BD%94%ED%94%84_%EC%97%B0%EC%87%84">마르코프 가정</a>에 따르면, <strong>“한 상태의 확률은 그 직전상태에만 의존한다.”</strong><br />(註. 위키에서는 “과거와 현재 상태가 주어졌을 때의 미래 상태의 조건부 확률 분포가 과거 상태와는 독립적으로 현재 상태에 의해서만 결정된다.”고 작성. 확실히 책의 설명이 훨씬 매끄럽다.)<br />예시에서는 <code class="language-plaintext highlighter-rouge">시간이다</code>가 등장할 확률은 <code class="language-plaintext highlighter-rouge">시간이다</code>의 직전상태, 즉 <code class="language-plaintext highlighter-rouge">할</code>에만 의존하는 것이다.
\(P(시간이다|이제,식사를,할)\approx\frac{Freq(할,시간이다)}{Freq(할)}=\frac{2}{341}\)
그렇다면 2-gram 모델 에서 <code class="language-plaintext highlighter-rouge">이제 식사를 할 시간이다</code>라는 시퀀스가 등장할 확률은 어떻게 되는가?<br />위와 같은 방식으로 구한 확률들을 전부 곱하는 것이다.<br />아래와 같이 말이다.
\(P(이제,식사를,할,시간이다)\\\approx P(이제)\times P(식사를|이제)\times P(할|식사를)\times P(시간이다|할) \\= \frac{112}{|V|}\frac{9}{112}\frac{7}{56}\frac{2}{341}\)
바이그램 모델을 일반화한 수식은 다음과 같다.
\(P(w_{n}|w_{n-1})=\frac{Freq(w_{n-1},w_n)}{Freq(w_{n-1})}\\P(w^n_1)=P(w_1,w_2,\cdots,w_n)= \prod^n_{k=1}P(w_k|w_{k-1})\)
(註. 책은 위와 같이 나왔지만, \(w_0\)이 없으니까. <a href="https://datascienceschool.net/view-notebook/a0c848e1e2d343d685e6077c35c4203b/">여기</a> 식을 참조해서 수치를 조정하는 것이 맞아보인다.<br />n-gram 모형의 경우 수식도 나왔으니 참고하자.)</p>

<p>이런 n-gram에도 아직 문제가 남아있다.<br />데이터에 한 번도 등장하지 않는 n-gram이 존재하면 아까와 마찬가지로 확률이 0이 된다.<br />이 현상은 데이터엔 등장하지 않는 희소한 단어가 있기 때문이다.</p>

<table>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">또바기</code>는 ‘언제나 한결같이 꼭 그렇게’ 라는 뜻의 한국어 부사다.<br />거의 쓰지 않는 단어이며, 나도 본 적이 없다.<br />만약 사용했다고 해도, 바이그램 모델은 <code class="language-plaintext highlighter-rouge">또바기</code>라는 단어 앞의 단어와 같이 쓴 적이 있어야 확률을 계산할 수 있다.<br /><code class="language-plaintext highlighter-rouge">그 아이는 또바기 인사를 잘한다</code>라는 문장에서 <code class="language-plaintext highlighter-rouge">또바기</code> 앞에 <code class="language-plaintext highlighter-rouge">아이는</code>이 나온 적이 없다면,<br />$$P(또바기</td>
      <td>아이는)=0$$ 이 되고, 바이그램 모델에서 이 문장이 자연스럽다고 여길 확률 역시 0이 된다.</td>
    </tr>
  </tbody>
</table>

<p>이를 해결할 방법은 2가지가 있다.<br />백오프(back-off), 스무딩(smoothing)이다.</p>

<p>백오프는 n-gram 등장빈도를 n보다 작은 범위의 단어 시퀀스 빈도로 근사하는 방식이다.<br />아까 빈도가 0인 문장 <code class="language-plaintext highlighter-rouge">이제 식사를 할 시간이다</code>는 4-gram이다.<br />이를 백오프를 통해 2-gram인 <code class="language-plaintext highlighter-rouge">할 시간이다</code>를 이용해 빈도를 보정하는 법은 아래와 같다.<br />(\(\alpha,\beta\) 는 빈도 차이를 보정하는 파라미터.)
\(Freq(이제,식사를,할,시간이다)\approx\beta+\alpha Freq(할,시간이다)\)
스무딩은 모든 표현에 k만큼 빈도를 더하는 것이다.<br />이러면 <code class="language-plaintext highlighter-rouge">이제 식사를 할 시간이다</code>는 0+k만큼 빈도를 갖는 것이다.<br />Add-k 스무딩이라고 하며, k가 1일 경우 특별히 <strong>라플라스 스무딩</strong>이라 한다.<br />이를 통해 빈도가 0인 케이스에도 일부 확률을 부여하게 된다.</p>

<p><strong>(2) 뉴럴 네트워크 기반 언어모델</strong></p>

<p>단어들의 빈도를 세서 학습하는 통계 기반 언어모델과 달리,<br />뉴럴 네트워크를 통해 입,출력 관계 자체로 확률모델을 만들 수 있다.<br />단어 시퀀스를 가지고 다음 단어를 예측하는 학습으로 ELMo, GPT 등이 있다.</p>

<p>시계열성을 띄는 시퀀스 대신 앞, 뒤 단어를 전부 고려하는 양방향 학습이 있다.<br /><strong>마스크 언어 모델</strong>이다. BERT가 대표적이다.</p>

<p>여기에 대해서는 차후 설명할 예정이다.</p>

<p><br /></p>

<hr />

<h2 id="4-뭔-단어가-같이-쓰였나">4. 뭔 단어가 같이 쓰였나</h2>

<p><strong>(1) 분포 가정</strong></p>

<p>자연어 처리에서 <strong>분포(distribution)</strong>란 특정 범위, <br />즉 윈도우(window)내에 동시 등장하는 이웃 단어 또는 문맥(context)의 집합을 가리킨다.</p>

<p>단어의 포는 단어가 문장 내에 나타나는 위치, 주변에 자주 등장하는 단어 여부에 따라 달라진다.<br /><u>어떤 단어의 쌍(pair)이 비슷한 문맥에서 자주 등장한다면 그 의미 또한 유사할 것</u>이라는 게 분포 가정의 전제다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">분포 가정</code></strong>은 “단어의 의미는 곧 그 언어에서의 활용이다”라는 언어학자 비트겐슈타인의 철학에 기반해 있다.<br />다시 말해 모국어 화자들의 문맥상 단어 사용을 통해 그 단어의 의미를 밝힐 수 있다는 것이다.</p>

<p><code class="language-plaintext highlighter-rouge">빨래</code>, <code class="language-plaintext highlighter-rouge">세탁</code>을 예시로 들어보자.</p>

<p>“<code class="language-plaintext highlighter-rouge">청소</code>와 <code class="language-plaintext highlighter-rouge">빨래</code>가 취미입니다.”<br />“뜨거운 <code class="language-plaintext highlighter-rouge">물</code>로 <code class="language-plaintext highlighter-rouge">빨래</code>를 합니다.”</p>

<p>“찬 <code class="language-plaintext highlighter-rouge">물</code>로 옷을 <code class="language-plaintext highlighter-rouge">세탁</code>한다.”<br />“<code class="language-plaintext highlighter-rouge">세탁</code>, <code class="language-plaintext highlighter-rouge">청소</code>는 귀찮은 일이다.”</p>

<p><code class="language-plaintext highlighter-rouge">빨래</code>, <code class="language-plaintext highlighter-rouge">세탁</code>은 타깃 단어(target word), <code class="language-plaintext highlighter-rouge">청소</code>,<code class="language-plaintext highlighter-rouge">물</code> 등은 타깃 단어 주의에 등장한 문맥 단어(context word)다.<br />주변 문맥 단어들이 비슷한 것으로 보아, 타깃 단어들끼리 관계가 있을 것이라 짐작할 수 있다.<br />이를 통해 <code class="language-plaintext highlighter-rouge">빨래</code>, <code class="language-plaintext highlighter-rouge">세탁</code>은 서로 비슷한 부류의 행동으로 파악할 수 있다.</p>

<p>하지만 직접적인 연관성이 있어 보이진 않는다.<br /><u>분포 정보가 곧 의미라는 분포 가정 자체에 의문이 제기될 수 있다는 소리다.</u><br />이를 해소하기 위해 언어학적 관점에서 분포 가정이 의미를 갖는 경우를 살펴보고자 한다.</p>

<p><strong>(2) 분포와 의미_1: 형태소</strong></p>

<p>언어학에서 형태소(morpheme)란 의미를 갖는 최소 단위를 말한다.<br />일반적으로, 단어를 쪼갰을 때 의미가 사라지면 쪼개기 전 단어를 형태소로 본다.<br /><code class="language-plaintext highlighter-rouge">밥</code>을 <code class="language-plaintext highlighter-rouge">ㅂ</code>, <code class="language-plaintext highlighter-rouge">압</code>으로 분리하면 의미가 사라지기 때문에 <code class="language-plaintext highlighter-rouge">밥</code>을 형태소로 보는 것이다.</p>

<p>언어학적으로 형태소를 분석하는 방법은 조금 다르다.<br />계열 관계(paradigmatic relation)가 대표적인 기준이다.<br />말뭉치(corpus)들을 대거 분석한 결과, <code class="language-plaintext highlighter-rouge">밥</code>이 <code class="language-plaintext highlighter-rouge">빵</code>으로 대신 쓰일 수 있다면,<br />이를 근거로 <code class="language-plaintext highlighter-rouge">밥</code>에 형태소 자격을 부여한다.</p>

<p>위와 같이, 언어학자들 역시 특정 타깃 단어 주변의 문맥정보를 바탕으로 형태소를 확인하고 있음을 알 수 있다.<br />말뭉치의 분포 정보와 형태소가 밀접한 관계를 이루고 있다는 것이다.</p>

<p><strong>(3) 분포와 의미_3: 품사</strong></p>

<p>언어학자들이 제시하는 품사 분류 기준은<br /><strong>의미(meaning)</strong>, <strong>형태(form)</strong>, <strong>기능(function)</strong> 등 세 가지다.</p>

<p>의미(meaning)는 실제 품사를 분류할 때 결정적 분류 기준이 될 수 없다.<br /><code class="language-plaintext highlighter-rouge">공부하다</code>, <code class="language-plaintext highlighter-rouge">공부</code>의 경우를 예시로 들어보자.<br />한국어 화자들은 <code class="language-plaintext highlighter-rouge">공부하다</code>는 동사, <code class="language-plaintext highlighter-rouge">공부</code>는 명사로 분류할 것이다.<br />하지만 <code class="language-plaintext highlighter-rouge">공부</code>라는 단어에 ‘움직임’이 없어서 동사로 구분하지 않는 것일까? 딱 잘라 말하기 어렵다.<br />의미가 결정적 분류기준이 아닌 이유다.</p>

<p>형태(form) 역시 마찬가지다.<br /><code class="language-plaintext highlighter-rouge">철수가 있다</code>와 <code class="language-plaintext highlighter-rouge">철수! 뭐해!</code> 에서 전자의 <code class="language-plaintext highlighter-rouge">철수</code>는 명사, 후자의 <code class="language-plaintext highlighter-rouge">철수</code>는 감탄사로 쓰였다.</p>

<p><strong>기능(function)</strong>이 바로 언어학자들이 꼽는 가장 중요한 품사 분류기준이다.<br />해당 단어가 문장 내에서 점하는 역할에 초점을 맞추는 것이다.<br />그런데 언어에서는 <u>단어의 **분포**가 **기능**과 매우 밀접하다고 한다.</u> <br />한국어 품사 분류의 일반적인 기준을 간단히 살펴봄으로써 마치겠다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>체언(명사): 관형사가 그 앞에 올 수 있고 조사가 그 뒤에 올 수 있음
용언(동사/형용사): 부사가 그 앞에 올 수 있고 선어말어미가 그 뒤에 올 수 있고 어말어미가 그 뒤에 와야함
관형사: 명사가 그 뒤에 와야 함
(이하 생략)
</code></pre></div></div>

<p>이러한 언어의 특성 덕분에 분포 정보를 함축한 <strong>벡터</strong>에 <strong>의미</strong>를 내재시킬 수 있다.</p>

<p><strong>(4) 점별 상호 정보량</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">점별 상호 정보량(Pointwise Mutual Infomation, PMI)</code></strong>은 두 확률변수(random variable) 사이의 상관성을 계량하는 단위다.<br />예를 들면, 단어 A가 등장하면 단어 B 등장할 확률이 얼마나 되는지 확인하는 것이다.<br />A가 나왔을 때 B가 자주 나타날 수록 PMI값이 커지고, B가 안 나올 수록 PMI값이 작아진다.<br />수식으로 표현하면 아래와 같다.
\(PMI(A,B)=log\frac{P(A,B)}{P(A)\times P(B)}\)
전체 빈도가 1,000회, <code class="language-plaintext highlighter-rouge">빨래</code>가 20회, <code class="language-plaintext highlighter-rouge">속옷</code>이 15회, <code class="language-plaintext highlighter-rouge">빨래</code>와 <code class="language-plaintext highlighter-rouge">속옷</code>이 동시 등장한 경우가 10회인 경우를 가정하자.<br />이 때 PMI값을 구하면 아래와 같다.
\(PMI(빨래,속옷)=log\frac{P(빨래,속옷)}{P(빨래)\times P(속옷)}=log\frac{\frac{10}{1000}}{\frac{20}{1000}\times\frac{15}{1000}}\)</p>

<p><strong>(5) Word2Vec</strong></p>

<p>Word2Vec은 구글 연구팀이 2013년 발표한 임베딩 기법이며, 분포 가정의 가장 대표적인 모델이다.<br />CBOW 모델은 문맥 단어들로 타깃 단어 하나를 맞추는 과정에서 학습된다.<br />Skip-gram 모델은 타깃 단어 하나로 문맥 단어를 예측하는 과정에서 학습된다.<br />둘 다 특정 타깃 단어 주변의 문맥, 즉 <u>분포 정보를 임베딩에 함축한다.</u><br />PMI 행렬과도 깊은 연관이 있다.</p>

<figure>
    <a href="\posts_image\nlp\ch2_word2vec.jpg"><img src="\posts_image\nlp\ch2_word2vec.jpg" /></a>
    <figcaption><center><b>CBOW와 Skip-gram 모델</b></center></figcaption>
</figure>

<p><br /></p>

<hr />

<h2 id="5-주요-내용">5. 주요 내용</h2>

<ul>
  <li>임베딩에 자연어의 통계적 패턴(statistical pattern) 정보를 주면 자연어의 의미(semantic)를 함축할 수 있다.</li>
  <li>백오브워즈 가정에서는 어떤 단어의 등장 여부 혹은 빈도 정보를 중시한다. 순서 정보는 무시한다.</li>
  <li>언어 모델은 위와 반대로 등장 순서를 학습해 주어진 단어 시퀀스가 얼마나 자연스러운지 확률을 부여한다.</li>
  <li>분포 가정에서는 문장에서 어떤 단어가 같이 쓰였는지를 중시한다.</li>
  <li>백오브워즈 가정, 언어 모델, 분포 가정은 말뭉치의 통계적 패턴을 다른 각도에서 분석하며, 상호 보완적이다.</li>
</ul>

<hr />

<p><br /></p>

<h4 id="참고">참고</h4>

<ul>
  <li><a href="http://acornpub.co.kr/book/korean-embedding">한국어 임베딩(2019)</a></li>
</ul>]]></content><author><name></name></author><category term="nlp" /><category term="nlp" /><category term="tfidf" /><category term="BoW" /><category term="ngram" /><summary type="html"><![CDATA[벡터와 자연어, 숫자가 의미를 갖는 과정]]></summary></entry><entry><title type="html">Gephi 기본 사용법</title><link href="http://localhost:4000/sna_gephi/" rel="alternate" type="text/html" title="Gephi 기본 사용법" /><published>2020-01-10T03:00:00+09:00</published><updated>2020-01-10T03:00:00+09:00</updated><id>http://localhost:4000/sna_gephi</id><content type="html" xml:base="http://localhost:4000/sna_gephi/"><![CDATA[<hr />

<h2 id="1-social-network-analysis">1. Social Network Analysis</h2>

<p>Social Network Analysis(SNA), 사회 연결망 분석은 연결망 데이터를 활용하여 사회 연결 구조를 분석하는 것이다.<br /><a href="[https://ko.wikipedia.org/wiki/%EC%82%AC%ED%9A%8C_%EC%97%B0%EA%B2%B0%EB%A7%9D_%EB%B6%84%EC%84%9D](https://ko.wikipedia.org/wiki/사회_연결망_분석)">위키백과 내용</a>을 참조하면 좋을 것이다.</p>

<p>나는 그 중에서도 Family tree 쪽을 보고 있다.<br />불완전 데이터를 다루고 있기 때문에 완벽한 Tree 시각화는 하지 못하고 있다.<br />오히려 일반적인 네트워크 시각화와 비슷하기 때문에,<br />혹시나 볼 사람이 있을까봐 포스팅 해두려고 한다.</p>

<hr />

<p><br /></p>

<h2 id="2-네트워크-분석-툴">2. 네트워크 분석 툴<br /></h2>

<p>네트워크 분석 툴은 여러가지가 있다.<br />그냥 내가 많이 건드린 애들만 나열해보겠다.<br /></p>

<p>(1) DB<br /><strong><code class="language-plaintext highlighter-rouge">Neo4j</code></strong> 라는 네트워크 DB가 있다.<br />cypher라는 NoSQL 쿼리문을 사용한다.<br />내가 사용할 땐 링크 depth를 찾다가 자꾸 DB서버가 터졌다.<br />일반 쿼리도 잘 못짜기 때문에 cypher 쿼리 작성도 힘들었다.<br />위와 같은 이유로 나는 네트워크 DB를 안 쓴다. <br />다른 네트워크 DB들도 있으니 궁금하면 찾아보길 바란다.</p>

<p>(2) Networkx<br />파이썬 이용한다면 <strong><code class="language-plaintext highlighter-rouge">networkx</code></strong> 사용하는 것이 괜찮다.<br />전처리를 하자마자 네트워크 구성을 할 수 있어서 좋았다.<br />헌데, 전문 프로그램들에 비해 좀 느리다.<br />네트워크 구성 알고리즘에 log가 없는 느낌이다.</p>

<p>(3) 그 외<br />UCINET 같이 유명한 툴도 있지만, <del>안 예뻐서</del> 쓰진 않았다.<br />NetMiner라는 툴은 꽤 좋긴 한데, 무료버전의 노드 수용량이 5천개 까지다.<br />Graphviz는 많은 플랫폼들에 api로 있다. 파이썬에도 있다.</p>

<p>(4) Gephi<br /><del>읽는 거는 사람마다 제피, 제파이, 게피, 게파이 참 다양하더라…</del><br />나는 시각화 부분에서는 <a href="https://gephi.org/">Gephi</a>를 이용하였다. <br />이걸 사용하는 이유는, 애니메이션 기능이 있어서다.<br />Timestamp 기반으로 애니메이션 해주는 것이 마음에 들었다.<br />속도도 networkx 보다 빨랐다.<br /></p>

<hr />

<p><br /></p>

<h2 id="3-gephi-사용법">3. Gephi 사용법</h2>

<p>작성 당시엔 생각보다 gephi 사용법에 대한 글이 없어보였다.<br />이런 약소한 수준의 글이라도 남겨두면 좋아보여 포스팅 하였다.</p>

<p>아래는 Gephi 화면이다.</p>

<figure>
    <a href="\posts_image\sna_gephi\gephi1.jpg"><img src="\posts_image\sna_gephi\gephi1.jpg" /></a>
    <figcaption><center><b>Gephi 첫 화면</b></center></figcaption>
</figure>

<p>처음에 깔고 실행하면 위 화면과는 다를 것이다.<br />이거는 상단에 <strong><code class="language-plaintext highlighter-rouge">도구-플러그인</code></strong>순으로 들어가서 모든 플러그인을 설치한 상태다.<br />그래프 알고리즘 등 쓸만한 애들이 많기 때문에 설치해두면 좋다.</p>

<h3 id="3-1-gephi---data-laboratory">3-1. Gephi - Data Laboratory</h3>

<figure>
    <a href="\posts_image\sna_gephi\gephi_DL.jpg"><img src="\posts_image\sna_gephi\gephi_DL.jpg" /></a>
    <figcaption><center><b>Data Laboratory 화면</b></center></figcaption>
</figure>

<p>네트워크 데이터를 넣어두고자 한다.<br />여기서 직접 만드는 방법도 있지만, 그렇게 편한 데이터를 넣을 리 없기 때문에<br />데이터 파일을 올리는 방식을 사용할 것이다.</p>

<p>사용할 데이터는 사육신과 관련된 사람들 + 가상인물 1명의 네트워크다.</p>

<p>미리 간단히 설명하자면,<br />Import Spreadsheet는 자료 불러오기<br />More actions는 edge 혹은 그래프 전체 삭제<br />Merge columns는 있는 데이터 기반으로 컬럼 생성<br />Copy data to other column은  그대로 데이터 복사다.</p>

<ul>
  <li>
    <p>I. Import Spreadsheet</p>

    <ul>
      <li>
        <p>데이터를 넣는 부분이다. xlsx, csv 등의 형식을 지원한다.</p>

        <p>※ UTF-8로 인코딩된 csv 파일은 첫번째 컬럼이 인식되지 않는 경우가 있다.<br />첫 번째 컬럼에 빈 컬럼을 추가하면 해결(?)된다.</p>
      </li>
      <li>
        <p>각각 필수적인 컬럼이 있다.<br />node는 Id, edge는 Source와 Target이 필요하다. (대문자 구분 필수)</p>
      </li>
    </ul>

    <figure class="half">
    <a href="\posts_image\sna_gephi\gephi_node.jpg"><img src="\posts_image\sna_gephi\gephi_node.jpg" /></a>
    <a href="\posts_image\sna_gephi\gephi_edge.jpg"><img src="\posts_image\sna_gephi\gephi_edge.jpg" /></a>
    <figcaption><center><b>사용할 node, edge 파일</b></center></figcaption>
</figure>

    <ul>
      <li>
        <p>테이블 속성을 지정한다. 여기서는 노드 테이블로 지정한다.</p>

        <figure>
    <a href="\posts_image\sna_gephi\gephi_IS1.jpg"><img src="\posts_image\sna_gephi\gephi_IS1.jpg" /></a>
</figure>
      </li>
      <li>
        <p>데이터 속성을 지정한다. <br />나중에 데이터 사용을 위해 시간 표현을 Intervals로 바꾸었다.</p>

        <figure>
    <a href="\posts_image\sna_gephi\gephi_IS2.jpg"><img src="\posts_image\sna_gephi\gephi_IS2.jpg" /></a>
</figure>
      </li>
      <li>
        <p>데이터를 추가한다. <br />그래프 타입은 direct, undirect가 있다.<br />edge의 방향성을 지정하는 것인데, 여기는 노드 부분이라 넘어간다.<br />데이터는 현재 workspace에 올리도록 조정하자.</p>

        <figure>
    <a href="\posts_image\sna_gephi\gephi_IS3.jpg"><img src="\posts_image\sna_gephi\gephi_IS3.jpg" /></a>
</figure>
      </li>
      <li>
        <p>데이터 업로드가 완료되었다. edge도 같은 방식으로 업로드하자.</p>

        <figure>
    <a href="\posts_image\sna_gephi\gephi_IS4.jpg"><img src="\posts_image\sna_gephi\gephi_IS4.jpg" /></a>
    <figcaption><center><b>업로드 완료된 node 파일</b></center></figcaption>
</figure>
      </li>
      <li>
        <p>​</p>
      </li>
    </ul>
  </li>
  <li>
    <p>II. More actions</p>

    <ul>
      <li>주로 쓸 기능은 edge 삭제와 graph 삭제다.<br />딱히 설명할 필요가 없어 넘어간다.</li>
    </ul>
  </li>
  <li>
    <p>III. Merge columns</p>

    <ul>
      <li>있는 데이터를 기반으로 컬럼을 생성한다.<br />Interval 만드는 걸로 예시를 들어보겠다.<br />처음과 끝에 해당하는 컬럼을 가져오고, <br />interval 만들기를 실행한다.</li>
    </ul>

    <figure>
    <a href="\posts_image\sna_gephi\gephi_MC1.jpg"><img src="\posts_image\sna_gephi\gephi_MC1.jpg" /></a>
</figure>

    <ul>
      <li>처음 컬럼과 끝 컬럼을 지정한다.<br />날짜 형식을 지정한다. 여러 형식이 있으니 그에 맞춰서 데이터를 만들자.<br />데이터를 포괄하는 시간 범위도 지정하고 마치면 된다.</li>
    </ul>

    <figure>
    <a href="\posts_image\sna_gephi\gephi_MC2.jpg"><img src="\posts_image\sna_gephi\gephi_MC2.jpg" /></a>
</figure>
  </li>
  <li>
    <p>IV. Copy data to other column</p>

    <ul>
      <li>말 그대로 데이터 복사다.<br />복사할 컬럼을 선택하고, 붙여넣을 컬럼을 선택하면 끝난다.</li>
      <li>Label을 채워야 그래프에 표시되기 때문에<br />name을 Label에 복사했다.<br />처음부터 자료의 컬럼명을 Label로 했으면 편할 것이다.</li>
    </ul>

    <figure>
    <a href="\posts_image\sna_gephi\gephi_CC.jpg"><img src="\posts_image\sna_gephi\gephi_CC.jpg" /></a>
    <figcaption><center><b>수정 완료된 node 파일</b></center></figcaption>
</figure>
  </li>
</ul>

<h3 id="3-2-gephi---overview">3-2. Gephi - Overview</h3>

<figure>
    <a href="\posts_image\sna_gephi\gephi_ov1.jpg"><img src="\posts_image\sna_gephi\gephi_ov1.jpg" /></a>
    <figcaption><center><b>Overview 화면</b></center></figcaption>
</figure>

<p>시각화 구성을 할 것이다.<br />처음엔 간단히 나오기 때문에 좀 다듬을 것이다.</p>

<p>미리 간단히 설명하자면,<br />Appearance는 노드, 엣지 외형 조정<br />Layout은 네트워크 알고리즘 선택이다.<br />번외로 시간 애니메이션 설정도 볼 것이다.</p>

<ul>
  <li>I. Appearnce
    <ul>
      <li>nodes 에서 순서대로 색깔, 크기, label 색깔, label 크기를 조절할 수 있다.
        <ul>
          <li>색깔을 예시로 들면,<br />unique는 전체 색깔을 조절한다.<br />partition은 지정한 속성(주로 분류)에 따라 색깔을 조절한다.<br />ranking은 지정한 속성(주로 수치)에 따라 색깔을 조절한다.</li>
        </ul>
      </li>
      <li>edges 에서 순서대로 색깔, label색깔, label 크기를 조절할 수 있다.<br />그 외엔 nodes 부분과 동일하므로 설명을 줄인다.</li>
      <li>Apply 누르면 바로 변경된다.<br />색깔, 크기 등 각 부분에서 하나만 적용된다.<br />아래 그래프에서 조정한 변수는 다음과 같다.
        <ul>
          <li>Nodes: 색깔-partition-family 변수, 크기-ranking-rank 변수</li>
          <li>Edges: 색깔-partition-attribute 변수</li>
          <li>그 외, 그래프 아래 부분을 보면 텍스트 표시나 링크 굵기 조절하는 부분이 있다.<br />한글폰트 넣어주면 폰트는 안 깨질 것이다.<br />링크 굵기는 Edge 데이터의 weight 값을 조절해줘도 변한다.</li>
        </ul>
      </li>
    </ul>

    <figure>
    <a href="\posts_image\sna_gephi\gephi_ov2.jpg"><img src="\posts_image\sna_gephi\gephi_ov2.jpg" /></a>
</figure>
  </li>
  <li>
    <p>II. Layout</p>

    <ul>
      <li>여러 알고리즘들이 들어있다.<br /> 여러가지 실험해보길 바란다.</li>
      <li>
        <p>종류에 따라 속도차이가 있다. 계산 방식 때문이다.<br /><a href="https://gephi.org/users/tutorial-layouts/">튜토리얼</a>을 봐도 되고,<br /><a href="https://www.slideshare.net/freshdatabos/visualizing-networks">여기 78번 슬라이드</a>에 누가 정리해 둔 자료를 봐도 된다.<br />복잡도가  N^2^ 으로 되어있는 애들은 데이터 많아지면 확실히 느리다.</p>
      </li>
      <li>아래는 ForceAtlas 2를 사용한 결과물이다.</li>
    </ul>

    <figure>
    <a href="\posts_image\sna_gephi\gephi_ov3.jpg"><img src="\posts_image\sna_gephi\gephi_ov3.jpg" /></a>
</figure>
  </li>
  <li>
    <p>III. Time</p>

    <ul>
      <li>시계열 혹은 특정 기간을 볼 수 있다.<br />재생시간도 조절 가능하다. 미세한 조정은 잘 안된다.</li>
      <li>왼쪽 아래 구석을 보면 환경설정이 가능하다.<br />나는 time format을 numeric에서 datetime으로 바꿨다.</li>
      <li>play setting에서 애니메이션 속도 및 형식을 바꿀 수 있다.<br />mode에 one bound는 누적, two bound는 기간설정 방식이다.</li>
    </ul>

    <figure>
    <a href="\posts_image\sna_gephi\gephi_time.jpg"><img src="\posts_image\sna_gephi\gephi_time.jpg" /></a>
    <figcaption><center><b>애니메이션 설정</b></center></figcaption>
</figure>

    <ul>
      <li>완료된 영상은 다음과 같다.</li>
    </ul>

    <figure>
    <a href="\posts_image\sna_gephi\gephi_result.gif"><img src="\posts_image\sna_gephi\gephi_result.gif" /></a>
    <figcaption><center><b>결과물</b></center></figcaption>
</figure>
  </li>
</ul>

<p>Preview는 내가 기능을 모르는 건지 모르겠는데, layout 재생을 적용할 수 없어서 그냥 안 썼다.</p>

<hr />

<p><br /></p>

<h2 id="4-활용">4. 활용</h2>

<p>내가 한 작업을 활용해보려고 한다.<br />결과물은 <a href="https://www.youtube.com/watch?v=F_p8ZOcWxR0">youtube</a>에 올렸다.<br />(많이 부족한 부분이 발견되어서 수정할 예정)</p>

<p>조선시대 과거 합격자 네트워크를 시각화한 것이다.<br />Layout은 ForceAtlas2 를 사용하였다.<br />시간은 연도를 기준으로 변화시켰다.</p>

<p>거의 하지도 않는 영상편집에 돈 쓰기 좀 그래서 텍스트를 직접 박았다.<br />1년 단위로 변하는걸 원했으나,<br />하나하나 수작업이 힘들어서 20년 단위로 해놨다.</p>

<hr />

<p><br /></p>

<h4 id="참고">참고</h4>

<ul>
  <li><a href="https://gephi.org/users/tutorial-layouts/">Gephi layout 튜토리얼</a></li>
  <li><a href="https://www.slideshare.net/freshdatabos/visualizing-networks">튜토리얼 정리</a></li>
</ul>]]></content><author><name></name></author><category term="graph" /><category term="gephi" /><summary type="html"><![CDATA[Gephi 튜토리얼]]></summary></entry><entry><title type="html">jekyll 번외 - 댓글 생성하기</title><link href="http://localhost:4000/jekyll_guide_4/" rel="alternate" type="text/html" title="jekyll 번외 - 댓글 생성하기" /><published>2019-12-26T23:00:00+09:00</published><updated>2019-12-26T23:00:00+09:00</updated><id>http://localhost:4000/jekyll_guide_4</id><content type="html" xml:base="http://localhost:4000/jekyll_guide_4/"><![CDATA[<hr />

<h2 id="1-댓글창-만들기"><strong>1. 댓글창 만들기</strong></h2>

<p>분명 theme에 댓글 기능이 있다고 들었는데 댓글이 작동하지 않았다.<br />알고 보니 댓글은 <a href="https://disqus.com/">disqus</a> 에서 제공해주는 것이었다.<br />서둘러 가입해서 댓글기능을 활성화시켰다.</p>

<hr />

<p><br /></p>

<h2 id="2-disqus-가입-및-활성화">2. disqus 가입 및 활성화</h2>

<p>글은 너무 시간낭비 같아서 최대한 사진으로 대체한다.</p>

<figure>
    <a href="\posts_image\jekyll_guide\disqus_sign.JPG"><img src="\posts_image\jekyll_guide\disqus_sign.JPG" /></a>
    <figcaption><center><b>가입한 e-mail로 인증 날아온다</b></center></figcaption>
</figure>

<figure>
    <a href="\posts_image\jekyll_guide\disqus_start.JPG"><img src="\posts_image\jekyll_guide\disqus_start.JPG" /></a>
    <figcaption><center><b>install Disqus 들어가기</b></center></figcaption>
</figure>

<p>다음 창에서는 이름 적당히 정하고 카테고리 고른 후 만들기 누르면 된다.<br /><del>중국, 일본, 베트남 다 있는데 Korean이 안 보인다. 남들은 한글버전 쓰던데</del></p>

<figure>
    <a href="\posts_image\jekyll_guide\disqus_price.JPG"><img src="\posts_image\jekyll_guide\disqus_price.JPG" /></a>
    <figcaption><center><b>그냥 basic 고르자</b></center></figcaption>
</figure>

<p>다음 창에서는 jekyll 고르면 된다.<br /></p>

<figure>
    <a href="\posts_image\jekyll_guide\disqus_install.JPG"><img src="\posts_image\jekyll_guide\disqus_install.JPG" /></a>
    <figcaption><center><b>인스톨 사항</b></center></figcaption>
</figure>

<p>필요한 layout에 <code class="language-plaintext highlighter-rouge">comments: true</code>를 달아주면 default 값으로 사용할 수 있다.<br />나는 <del>뻘</del>글 쓸 때 쓰는 layout인 <code class="language-plaintext highlighter-rouge">post.html</code>에 달아줬다.</p>

<p>2번에 <code class="language-plaintext highlighter-rouge">Universal Embed Code</code>라고 나온 부분은 잘 모르겠다.<br />따로 설치해야하는 건가;;</p>

<figure> 
    <a href="\posts_image\jekyll_guide\disqus_set.JPG"><img src="\posts_image\jekyll_guide\disqus_set.JPG" /></a>
    <figcaption><center><b>자기 블로그 주소 입력</b></center></figcaption>
</figure>

<p><span style="color:#ff0000">여기서는 주의할 점이 있다.</span><br /><code class="language-plaintext highlighter-rouge">_config.yml</code> 에 적었던 url 그대로 적어야 한다.<br />나는 https://tinygun.github.io 에다 <code class="language-plaintext highlighter-rouge">/</code> 를 붙여서 적었는데, <br />알고 보니 내 주소는 마지막 <code class="language-plaintext highlighter-rouge">/</code> 가 없어서 댓글 활성화가 안 됐다.</p>

<figure> 
    <a href="\posts_image\jekyll_guide\disqus_act.JPG"><img src="\posts_image\jekyll_guide\disqus_act.JPG" /></a>
    <figcaption><center><b>결국 댓글 활성화</b></center></figcaption>
</figure>

<hr />

<p><br /></p>

<h2 id="3-마치며">3. 마치며</h2>

<p>jekyll 에서 disqus 댓글창을 달아주는 작업을 했다.<br />나중에 Korean이 내 눈에 보이면 바로 수정해줘야겠다.</p>

<hr />

<p><br /></p>

<h4 id="참고">참고</h4>

<ul>
  <li><a href="https://17billion.github.io/jekyll/disqus/reply/2017/06/01/jekyll_disqus.html">https://17billion.github.io/jekyll/disqus/reply/2017/06/01/jekyll_disqus.html</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="jekyll" /><category term="github" /><category term="disqus" /><summary type="html"><![CDATA[댓글 기능 생성]]></summary></entry><entry><title type="html">블로그 갖고 싶어 시작한 jekyll(3)</title><link href="http://localhost:4000/jekyll_guide_3/" rel="alternate" type="text/html" title="블로그 갖고 싶어 시작한 jekyll(3)" /><published>2019-12-26T12:00:00+09:00</published><updated>2019-12-26T12:00:00+09:00</updated><id>http://localhost:4000/jekyll_guide_3</id><content type="html" xml:base="http://localhost:4000/jekyll_guide_3/"><![CDATA[<hr />

<h2 id="1-블로그-호스팅"><strong>1. 블로그 호스팅</strong></h2>

<p>구글 기능들을 블로그에 박기 위해 세상에 드러낼 필요가 있다.<br />이런 저질 블로그를 올려도 되는지 걱정될 수 있으나, 걱정할 필요가 없다.<br />구글에서 검색이 가능하려면 <a href="https://wayhome25.github.io/etc/2017/02/20/google-search-sitemap-jekyll/">추가적 절차</a>가 필요하다.<br />이건 그냥 호스팅일 뿐.</p>

<p>우선 github에 자신 주소로 사용할 이름의 저장소를 만들자.<br />나는 <strong><a href="https://github.com/tinygun/tinygun.github.io">tinygun.github.io</a></strong> 라고 만들었다.<br />이렇게 해야 호스팅이 된다고 한다.<br />미리 이름을 정하고 만들면 404 뜨는 듯하다.</p>

<p>원래 귀찮아서 github에 드래그로 옮길라고 했다.<br />그런데 파일이 100개 이상이라서 안 올라간다.<br />나중에 관리상 문제도 있어서 <a href="https://gitforwindows.org/">git</a> 으로 올린다.</p>

<hr />

<p><br /></p>

<h2 id="2-간단한-git-사용법"><strong>2. 간단한 git 사용법</strong></h2>

<p>다른 분들 검색하면 잘 나오긴 하지만, 그냥 편하게 여기다 쓴다.<br />완전 처음일 경우를 가정한다.</p>

<p>Windows 기준으로 <a href="https://git-scm.com/">git bash</a> 실행 후, 블로그 작업 폴더에 들어가서 다음과 같이 실행한다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git init
git add .

git config --global user.name "username"
git config --global user.email "username@example.com"

git commit -m "first commit"
git remote add origin "https://github.com/username/username.github.io.git"

git config --global http.postBuffer 20971520

git push -u origin master
</code></pre></div></div>

<p>(1) git에 필요한 파일을 만든다.<br />(2) 자기 신원을 적어둔다.<br />(3) 저장소에 연결한다.<br />(4) 파일 전송 크기를 조정한다. (선택사항)<br />(5) github에 올린다.</p>

<p><br /></p>

<p>나중에 파일을 수정하고 다시 올릴 때는 이러면 된다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git add .
git commit -m "수정내용"
git push -u origin master
</code></pre></div></div>

<p>확인해보면 github에 잘 올라가있다.<br /><code class="language-plaintext highlighter-rouge">_config.yml</code> 파일에서 자기가 지정한 주소로 접속하면 변경사항이 바로 안 뜰 수도 있다.<br />길게는 1분 정도 있어야 변경사항이 적용된다.</p>

<hr />

<p><br /></p>

<h2 id="3-검색기능-활성화">3. 검색기능 활성화</h2>

<p>참고: <a href="https://wayhome25.github.io/">https://wayhome25.github.io/</a></p>

<p>이제 호스팅을 했으니 깡통으로 만든 검색창에 기능을 추가하고자 한다.</p>

<p><br /></p>

<p>(1) 인증</p>

<p>구글에 검색이 가능하도록 <strong><code class="language-plaintext highlighter-rouge">인증</code></strong>을 먼저 진행한다.<br /><a href="https://search.google.com/search-console/welcome?hl=ko&amp;utm_source=wmx&amp;utm_medium=deprecation-pane&amp;utm_content=home">Search Console</a>로 들어가보자.</p>

<p>첫 화면 입력창에 자기 블로그 주소를 넣어주면  html을 받을 수 있다.<br />창은 나중에 꺼두자.<br />이걸 받고 github에 올려준 뒤 html 받던 창에서 확인을 눌러준다.</p>

<p><br /></p>

<p>(2) sitemap 제출</p>

<p>그 후, <code class="language-plaintext highlighter-rouge">sitemap.xml</code> 파일을 만들어야 한다.<br />난 <a href="https://github.com/wayhome25/wayhome25.github.io/blob/master/sitemap.xml">이 분</a> 것을 그대로 복사했다.<br />만들어 준 뒤 다시 github에 올려준다.<br />Search Console을 다시 들어가보면, 왼쪽에 <code class="language-plaintext highlighter-rouge">색인-Sitemaps</code> 부분이 있다.<br />여기 들어간 뒤 상단에 <code class="language-plaintext highlighter-rouge">sitemap.xml</code> 쓰고 사이트맵 추가하면 끝난다.</p>

<hr />

<p><br /></p>

<h2 id="4-검색기능-추가">4. 검색기능 추가</h2>

<p>드디어 검색기능을 활성화 시켰다.<br />이제 <a href="https://cse.google.co.kr/cse/">구글 맞춤검색</a>으로 들어가보자.</p>

<figure>
    <a href="\posts_image\jekyll_guide\googlesearch.JPG"><img src="\posts_image\jekyll_guide\googlesearch.JPG" /></a>
    <figcaption><center><b>맞춤검색 엔진 사이트</b></center></figcaption>
</figure>

<p>만들기 들어가서 자기 주소에 대한 검색엔진을 만들어보자.</p>

<p>검색엔진 수정을 통해 약간 수정한 뒤 <code class="language-plaintext highlighter-rouge">코드생성</code>이 있다.<br />해당 코드를 웹페이지에 추가하면 된다.<br />나는 layout 중 page를 기반으로 search의 index.html을 수정했다.</p>

<p>검색이 되려면, 좀 오래 걸린다고 들었다.<br />언젠가 될 때를 기약하자.</p>

<p>가끔 블로그 업데이트가 안 될 때가 있다.<br />나는 html 파일이 맛이 가서 안 된다고 메일만 20개 넘게 온 듯하다.<br />1분 넘으면 뭔가 문제가 있는 것이니 해결하자.</p>

<hr />

<p><br /></p>

<h2 id="5-마치며">5. 마치며</h2>

<p>드디어 github에 블로그를 개설했다.<br />많이 힘들었지만, 어느 정도 해결할 수 있어서 좋았다.<br />많은 블로그들을 돌아다니면서 공부해서 좋았다.</p>

<hr />

<p><br /></p>

<h2 id="그-동안-참고한-페이지들">그 동안 참고한 페이지들</h2>

<h4 id="주요-참고">주요 참고</h4>

<ul>
  <li>
    <p><a href="https://jekyllrb-ko.github.io/">https://jekyllrb-ko.github.io/</a>: 지킬 공식 한국어 홈피.</p>
  </li>
  <li>
    <p><a href="https://github.com/TaylanTatli/Moon">https://github.com/TaylanTatli/Moon</a>: 기본 테마.</p>
  </li>
  <li>
    <p><a href="https://nachwon.github.io/">https://nachwon.github.io/</a>: 다중 nav 참고. 수록 포스팅 들도 괜찮았던 블로그.</p>
  </li>
  <li>
    <p><a href="https://wayhome25.github.io/">https://wayhome25.github.io/</a>: search 기능 제작에 큰 도움.</p>

    <p><br /></p>
  </li>
</ul>

<h4 id="살짝-참고">살짝 참고</h4>

<ul>
  <li><a href="https://cropius.github.io/">https://cropius.github.io/</a>: sns 아이콘 정리에 도움.</li>
  <li><a href="http://dmcwo.github.io/Notebook-Moon//">http://dmcwo.github.io/Notebook-Moon//</a>: 폰트도 바꿔보면 좋겠다는 생각.</li>
  <li><a href="https://evasivepangolin.github.io/midtndsa//">https://evasivepangolin.github.io/midtndsa//</a>: 홈 화면을 깔끔하게 만들어서 신선.</li>
  <li><a href="https://rodriguez-r.com/">https://rodriguez-r.com/</a>: 최근 게시물을 올리는 것이 재미있어 보였다. 근데 나한텐 더러워보여</li>
  <li><a href="http://blog.knowgari.com/categories/Ajax/">http://blog.knowgari.com/categories/Ajax/</a>: 카테고리 페이지를 따로 만들어서 좋아보였다. 근데 모바일에선 적용이 되질 않아서 가져오진 않았다.</li>
  <li><a href="http://labs.brandi.co.kr/2018/05/14/chunbs.html">http://blog.knowgari.com/categories/Ajax/</a>: admin 기능을 소개해줬는데, 딱히 내게 많은 편의를 주는 기능은 아니었다. 저자 기능이 있으니 한 번 추가하고 싶다면 가도 좋다.</li>
  <li>
    <p><a href="http://jihyeleee.com/blog/second-designer-can-make-jekyll-blog/">http://jihyeleee.com/blog/second-designer-can-make-jekyll-blog/</a>: 내가 git을 잘 사용하지 못해서 나중에 더 참고하면 좋아보인다.</p>
  </li>
  <li>그 외 기본 테마에 <a href="https://github.com/TaylanTatli/Moon/network/members">fork</a> 해서 내게 영감을 준 블로그들.</li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="jekyll" /><category term="github" /><summary type="html"><![CDATA[블로그 호스팅 절차 및 Jekyll 검색기능 등 추가 기능 생성.]]></summary></entry><entry><title type="html">블로그 갖고 싶어 시작한 jekyll(2)</title><link href="http://localhost:4000/jekyll_guide_2/" rel="alternate" type="text/html" title="블로그 갖고 싶어 시작한 jekyll(2)" /><published>2019-12-24T09:00:00+09:00</published><updated>2019-12-24T09:00:00+09:00</updated><id>http://localhost:4000/jekyll_guide_2</id><content type="html" xml:base="http://localhost:4000/jekyll_guide_2/"><![CDATA[<hr />

<h2 id="1-theme-설정"><strong>1. Theme 설정</strong></h2>

<p>좋은 테마를 찾았다. <a href="https://github.com/TaylanTatli/Moon">Moon</a> 이라는 테마다.<br />좌측 상단에 게시판 링크를 고정한 것이 마음에 든다.<br />2019.12.24 기준으로 내 블로그 테마다.</p>

<p>테마를 받은 후, <code class="language-plaintext highlighter-rouge">_config.yml</code>이라는 파일을 변경해야 한다.<br />주로 바꿀 부분은 다음과 같다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>title:	Study &amp; Store
bio:	"Let's learn"
url:	127.0.0.1:4000
</code></pre></div></div>

<p>자기 블로그 간판, 설명, 주소를 적으면 된다.<br />지금은 jekyll 작동 시험중이라 주소를 로컬로 적어놨다.</p>

<p>왠지 모르겠는데 여기 한글이 들어가면 작동을 안한다.<br />로컬에서만 그러고 github에서는 괜찮은 듯하다.</p>

<p><code class="language-plaintext highlighter-rouge">_config.yml</code> 파일은 어떤 테마든 다 존재하는 환경설정 파일이다.<br />이 파일의 수정내역은 jekyll 재시작 후 반영된다.<br />배경이나 사진이 안 바뀐다고 혼란스러워 하지 말자.</p>

<p>p.s. <br />나는 Moon 테마로 jekyll을 돌리면 루비 콘솔에서</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">BigDecimal</span><span class="p">.</span><span class="nf">new</span> <span class="n">is</span> <span class="n">deprecated</span><span class="p">;</span> <span class="n">use</span> <span class="no">BigDecimal</span><span class="p">()</span> <span class="nb">method</span> <span class="n">instead</span>
</code></pre></div></div>

<p>라고 자꾸 경고 메시지를 날렸다. <br />콘솔에 문제있다고 하는 파일 경로가 뜬다.<br />메모장 같은거로 파일을 열어서 <code class="language-plaintext highlighter-rouge">BigDecimal.new</code> 라고 된 부분에서 <code class="language-plaintext highlighter-rouge">.new</code> 부분을 지웠다.<br />jekyll을 재시작하니 다시는 나타나지 않았다.<br />루비를 잘 모르지만, 아마 루비 버전에 따른 명령어 변화가 아닐까 싶다.</p>

<hr />

<p><br /></p>

<h2 id="2-기능-추가-리스트"><strong>2. 기능 추가 리스트</strong></h2>

<p>이제 내가 원하는 기능을 추가할 것이다.<br />추가하고 싶은 리스트는 다음과 같다.</p>

<ul>
  <li>게시판</li>
  <li>검색기능</li>
  <li>사용자 집계</li>
  <li><del>google 광고</del></li>
</ul>

<p>우선 레이아웃을 짜보자.<br />현재 사용하는 Moon 테마는 Home, Project 같은 별도 공간이 존재한다.<br />Posts 에서는 All Posts, All Tags로 볼 수 있는 편의를 제공한다.<br /></p>

<p>우선 다른 사람들이 어떻게 만들었는지 보면서 살펴보는게 편해보인다.</p>

<hr />

<p><br /></p>

<h2 id="3-다른-사람-블로그-참조하기"><strong>3. 다른 사람 블로그 참조하기</strong></h2>

<p>지피지기(知彼知己)면 백전불태(百戰不殆)라.<br />남을 알고 나를 알면 위태로움이 없다는 것이다.<br />남들을 우선 알아두면 블로그 작성 방향은 보인다.</p>

<p><a href="https://github.com/TaylanTatli/Moon">해당 테마</a>를 사용하는 사람들은 해당 깃허브 우측 상단에 <a href="https://github.com/TaylanTatli/Moon/network/members">fork</a>한 사람들을 참조하면 된다.<br />숫자 부분을 누르면 퍼간 사람들이 보인다.<br />기존 테마 이름을 바꾼 애들 주소 복사하고 들어가면 된다.<br />거의 기본테마 수준인 블로그가 많지만, 참신한 블로그도 많다.<br /></p>

<p><br /></p>

<p>게시판은 Posts를 누르면 All Posts 같은 느낌으로 나오도록 만드는 게 좋아보인다.<br />다른 블로그들은 카테고리도 만들어서 이걸 모아두는 페이지를 게시판인 것처럼 활용한다.<br />하지만 능력의 부족으로 인해 그냥 태그만 가지고 게시판을 만들겠다.</p>

<p>검색기능은 Project 같이 따로 search라는 이름으로 만드는 편이 좋아보인다.<br />거기서 검색 돌리면 바로 가도록 해도 괜찮아보인다.</p>

<p>사용자 집계는… 화면에 항상 떠있게 만들고 싶은데 힘들어 보인다.<br />Home 화면에 구겨 넣을 수 있다면 차라리 나아보인다.<br />음악 넣는 사람도 있었으니 충분히 가능할 것이다.</p>

<hr />

<p><br /></p>

<h2 id="4-게시판-만들기"><strong>4. 게시판 만들기</strong></h2>

<p>참조: https://nachwon.github.io/</p>

<p>우선 내가 건드린 파일은 다음과 같다.</p>

<ul>
  <li>/_layouts/post-list.html</li>
  <li>/_includes/nav.html</li>
</ul>

<p>post-list.html 은 이해를 잘 못해서 참조 사이트 것을 그대로 복사했다.<br />정신이 쇠약하고 지식이 부족하여 설명을 못하겠다.<br /></p>

<p>nav.html은 메뉴 영역을 담당하는 부분이다.<br />내가 바꾼 부분을 적당히 설명한다.</p>

<hr />

<p><strong>(1) Home</strong></p>

<p>게시판은 아니지만 같이 작업했으니 설명한다.</p>

<p>원본</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">"http://localhost:4000/"</span><span class="nt">&gt;</span>Home<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
</code></pre></div></div>

<p>변형</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">"http://localhost:4000/"</span><span class="nt">&gt;&lt;i</span> <span class="na">class=</span><span class="s">"fa fa-home"</span> <span class="na">style=</span><span class="s">"color:#808080"</span><span class="nt">&gt;</span><span class="ni">&amp;nbsp;&amp;nbsp;</span><span class="nt">&lt;/i&gt;</span>Main<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
</code></pre></div></div>

<p>아이콘을 넣고 이름을 Main으로 바꿨다.</p>

<p>i 부분의 class는 favicon(favorite icon)을 넣은 것이다.<br /><a href="https://fontawesome.com/icons?d=gallery">fontawesome</a>에서 검색한 뒤 들어가면 해당 아이콘의 html 태그가 나온다.<br />위와 같은 식으로 붙이면 된다.<br />(fas fa-home 같은 애들은 안돼서 fa fa-home으로 대체)</p>

<p>색깔은 RGB 색상 대충 맘에 드는 거 때려 넣었다.</p>

<p><code class="language-plaintext highlighter-rouge">&amp;nbsp;</code>은 띄어쓰기다. tab이 안 먹어서 그냥 띄어쓰기 몇 번을 썼다.</p>

<hr />

<p><strong>(2) Posts</strong></p>

<p>원본</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;li&gt;</span>
	<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Posts<span class="nt">&lt;/a&gt;</span>	
	<span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">"dl-submenu"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">"http://localhost:4000/posts/"</span><span class="nt">&gt;</span>All Posts<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
		<span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">"http://localhost:4000/tags/"</span><span class="nt">&gt;</span>All Tags<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
	<span class="nt">&lt;/ul&gt;</span>
<span class="nt">&lt;/li&gt;</span>
</code></pre></div></div>

<p>변형</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;li&gt;</span>
	<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;&lt;i</span> <span class="na">class=</span><span class="s">"fa fa-clone"</span> <span class="na">style=</span><span class="s">"color:#808080"</span><span class="nt">&gt;&lt;/i&gt;</span><span class="ni">&amp;nbsp;&amp;nbsp;</span>Posts<span class="nt">&lt;/a&gt;</span>	
	<span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">"dl-submenu"</span><span class="nt">&gt;</span>
		<span class="nt">&lt;li&gt;</span>
			<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;&lt;i</span> <span class="na">class=</span><span class="s">"fa fa-list"</span> <span class="na">style=</span><span class="s">"color:#808080"</span><span class="nt">&gt;&lt;/i&gt;</span><span class="ni">&amp;nbsp;&amp;nbsp;</span>Boards<span class="nt">&lt;/a&gt;</span>
			<span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">"dl-submenu"</span><span class="nt">&gt;</span>
				<span class="nt">&lt;li&gt;</span>
					<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"http://localhost:4000/posts/etc/"</span><span class="nt">&gt;</span>etc<span class="nt">&lt;/a&gt;</span><span class="c">&lt;!-- 게시판 부분--&gt;</span>&gt;
				<span class="nt">&lt;/li&gt;</span>
			<span class="nt">&lt;/ul&gt;</span>
		<span class="nt">&lt;/li&gt;</span>
		<span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">"http://localhost:4000/tags/"</span><span class="nt">&gt;&lt;i</span> <span class="na">class=</span><span class="s">"fa fa-tags"</span> <span class="na">style=</span><span class="s">"color:#808080"</span><span class="nt">&gt;&lt;/i&gt;</span><span class="ni">&amp;nbsp;&amp;nbsp;</span>tags<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
		<span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">"http://localhost:4000/posts/"</span><span class="nt">&gt;&lt;i</span> <span class="na">class=</span><span class="s">"fa fa-globe"</span> <span class="na">style=</span><span class="s">"color:#808080"</span><span class="nt">&gt;&lt;/i&gt;</span><span class="ni">&amp;nbsp;&amp;nbsp;</span>All<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
	<span class="nt">&lt;/ul&gt;</span>
<span class="nt">&lt;/li&gt;</span>
</code></pre></div></div>

<p>아이콘은 아까와 같은 방법으로 넣었다.</p>

<p><code class="language-plaintext highlighter-rouge">&lt;ul class="dl-submenu"&gt;</code> 부분을 넣어줌으로써 메뉴를 다중으로 다룰 수 있게 되었다.<br />Posts를 누르고 Board를 누르고 etc를 누르면 etc에 해당하는 글들이 등장한다.</p>

<p>저 위에 해당 폴더 경로를 잘 설정할 필요가 있다.<br />폴더 root에 보면 각 메뉴에 해당하는 폴더가 있고, 그 안에 index.md가 있을 것이다.<br />파일과 폴더를 만들어주고 여기서 해당하는 경로를 설정해야 글이 잘 들어간다.</p>

<p>그냥 자동으로 카테고리별 게시판을 만들 수도 있어보이는데,<br />방법을 잘 몰라서 이렇게 해야겠다.</p>

<p>p.s. 나중에 보니 게시판 추가에 문제가 있어서 원상복구했다.</p>

<hr />

<p><br /></p>

<h2 id="5-각종-페이지-정비"><strong>5. 각종 페이지 정비</strong></h2>

<p>지금까지 살펴보면 페이지 정비를 위해 들른 폴더는 다음과 같다.</p>

<ul>
  <li>_includes</li>
  <li>_layout</li>
</ul>

<p>레이아웃에 들어갈 물품(ex. nav.html)들은 _includes에 있었다.<br />이들을 제외하면 대부분 레이아웃만 조정하면 된다.<br />즉, _layout에 있는 페이지들을 정비할 필요가 있다.</p>

<p>home 화면(나한테는 main 화면)은 home.html을 조정하면 된다.<br />그 외 나머지는 index.md 등 인덱스 파일이 어떤 layout을 지정했는지 확인하자.<br />그 애들을 조정하면 해결된다.</p>

<p>코드 위치와 색상, class, 링크 수정 정도만 해도 난 충분하다고 생각했다.<br />위에서 했던 수준으로 하니까 할 수 있어서 자세히 설명하진 않는다.</p>

<p>난 SNS 마크가 거슬려서 박스를 지우고 아래로 치워버렸다.<br />메인 화면에 검색 기능이 바로 보이도록 하고 싶었지만,<br />모바일 환경에서만 이쁘고 데스크탑에선 안 이뻐서 그냥 nav에 통합했다.</p>

<p>Home 화면 버튼 색깔의 경우, 테마 다운 받으면 있던 글들에 정보가 있었다.<br />마크다운 문법 등 가이드가 많이 있어서 어느 정도 참조했다.</p>

<hr />

<p><br /></p>

<h2 id="6-검색-기능-만들기"><strong>6. 검색 기능 만들기</strong></h2>

<p>검색창은 어찌저찌 만들었지만, 검색 기능이 없으면 쓸모가 없다.<br />이제부터 검색기능에 대해 알아보려 한다.</p>

<p>검색기능을 만들기 위해서는 _layout 폴더에 해당 기능 레이아웃이 있어야 한다.<br />여기서는 page를 기반으로 검색기능을 넣으면 될 듯 하다. <br /><span style="color:#F0F0F0"><del>지금이라도 쉽다고 한 사기꾼 잡아와야 한다니까</del></span></p>

<p><a href="https://wayhome25.github.io/etc/2017/02/23/blog-search/">검색기능 추가</a>는 금방 만들 수 있어보인다.<br />나는 편의를 위해 구글 맞춤 검색을 이용할 것이다.<br />다만, 구글 맞춤 검색의 경우, 정식 호스팅 후에 구동이 가능해서 나중에 하도록 한다.</p>]]></content><author><name></name></author><category term="jekyll" /><category term="jekyll" /><category term="github" /><summary type="html"><![CDATA[Jekyll 테마 "Moon" 적용, 게시판 생성 및 페이지 커스터마이징.]]></summary></entry><entry><title type="html">블로그 갖고 싶어 시작한 jekyll(1)</title><link href="http://localhost:4000/jekyll_guide_1/" rel="alternate" type="text/html" title="블로그 갖고 싶어 시작한 jekyll(1)" /><published>2019-12-20T22:15:00+09:00</published><updated>2019-12-20T22:15:00+09:00</updated><id>http://localhost:4000/jekyll_guide_1</id><content type="html" xml:base="http://localhost:4000/jekyll_guide_1/"><![CDATA[<h2 id="1-github-블로그-시작"><strong>1. github 블로그 시작</strong></h2>

<p>공부하다 보니 코드를 보기 쉽게 정리해둘 필요성을 느꼈다.<br />주석을 간단히 달아두는 정도로는 보기 너무 불편했다.<br />그래서 생각한 것이 블로그였다.<br />하지만 기존 블로그들은 뭔가 마음에 들지 않았을 때 보인 블로그 형식이 바로,<br /></p>

<p><strong>“github.io”</strong> <br /></p>

<p>뭔가 있어보이는 저런도메인을 쓰고 싶었다. <br /></p>

<p>처음엔 n*ver나 d*um처럼 개인 공간 주고 꾸미는 줄 알았다. <br />얼핏 듣기로도 만들기는 쉽다고 들었다.<br /></p>

<p>하지만 내가 직접 호스팅하는 것이었고…<br />그렇게 블로그 제작의 수렁으로 빠졌다.<br /></p>

<hr />

<p><br /></p>

<h2 id="2-jekyll-시작하기에-앞서서"><strong>2. jekyll 시작하기에 앞서서…</strong></h2>

<p>github에 호스팅하는 것은 여러 방법이 있는 듯 하다.<br /><strong>jekyll</strong>은 그 중 하나다. <br /><a href="https://jekyllrb-ko.github.io/docs/home/">한국어 jekyll 설명서</a>를 보면서 해보면 어느 정도 만들 수 있다.</p>

<figure>
    <a href="/posts_image/jekyll_guide/simplejekyll.JPG"><img src="/posts_image/jekyll_guide/simplejekyll.JPG" /></a>
    <figcaption><center><b>그렇다. 아주 심플하게 날 속였다.</b></center></figcaption>
</figure>

<p>나는 Windows 10 에서 만들고자 한다.<br />필요한 절차는 다음과 같다.<br /><br /></p>

<p>(1) <a href="https://rubyinstaller.org/downloads/">Ruby, Ruby+Devkit</a> 다운 받기<br /></p>

<p>(2) <strong><code class="language-plaintext highlighter-rouge">Start Command Prompt with Ruby</code></strong>를 윈도우 검색창에 치고 관리자 권한으로 실행<br /></p>

<p>(3) 다음 코드 실행</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">chcp</span> <span class="mi">65001</span>						   <span class="c1">## 인코딩 오류 방지</span>
<span class="n">gem</span> <span class="n">install</span> <span class="n">bundler</span> <span class="n">jekyll</span>			<span class="c1">## bundler, jekyll 받기</span>
<span class="n">jekyll</span> <span class="n">new</span> <span class="n">my</span><span class="o">-</span><span class="n">awesome</span><span class="o">-</span><span class="n">site</span> 			<span class="c1">## 작업중인 디렉토리에서 "my-awesome-site"라는 폴더 만들고 거기다 설정파일 생성.</span>
<span class="n">cd</span> <span class="n">my</span><span class="o">-</span><span class="n">awesome</span><span class="o">-</span><span class="n">site</span>				    <span class="c1">## 만든 폴더로 들어가기</span>
<span class="n">bundle</span> <span class="n">add</span> <span class="n">webrick</span>				    <span class="c1">## Ruby 3.0.0 이상 사용 시 추가</span>
<span class="n">bundle</span> <span class="nb">exec</span> <span class="n">jekyll</span> <span class="n">serve</span>			<span class="c1">## jekyll 실행.</span>
</code></pre></div></div>

<p>bundle을 이용하지 않고 jekyll serve만 실행하면 각종 dependency 문제가 발생한다.<br />(주로 매우 구버전에서 만든 것에서 호환성 문제가 많은 듯하다. 가끔 bundle도 안된다)<br /></p>

<p>위와 같이 실행한 후, <a href="http://127.0.0.1:4000">127.0.0.1:4000</a>로 들어가거나 <a href="http://localhost:4000/">localhost:4000</a>로 들어가면 기본 화면이 나온다.</p>

<figure>
    <a href="/posts_image/jekyll_guide/jekyll_base.JPG"><img src="/posts_image/jekyll_guide/jekyll_base.JPG" /></a>
    <figcaption><center><b>Jekyll이 잘 작동중이다</b></center></figcaption>
</figure>

<hr />

<p><br /></p>

<h2 id="3-게시판을-만들어보자"><strong>3. 게시판을 만들어보자</strong></h2>

<p>글들을 정리해서 넣기 위해 각종 게시판을 만들려고 했다.<br />그런데, 아무리 봐도 내가 생각하던 블로그가 아니다.<br />게시판을 만들 수 있는 관리자 링크가 없다.<br />아니, 애초에 글쓰기 부분도 없다.</p>

<hr />

<p><br /></p>

<h2 id="4-글이라도-써보기"><strong>4. 글이라도 써보기</strong></h2>

<p>우선 첫 화면에 Welcome to Jekyll! 이라는 글처럼 하나 써보기라도 해야하지 않는가?<br />이건 그래도 markdown 문서를 사용하면 가능하다.<br />markdown 편집 프로그램 중 Typora 가 편해서 잘 사용하고 있다.<br />jupyter notebook 덕에 markdown을 많이 사용했는데, 이게 제작진행에 도움이 되었다.<br /></p>

<p>만든 폴더를 살펴보면 <code class="language-plaintext highlighter-rouge">_posts</code>라는 폴더가 보인다.<br /><code class="language-plaintext highlighter-rouge">yyyy-mm-dd-welcome-to-jekyll.markdown</code> 같은 이름의 문서가 들어있다. <br />이 문서 보면서 비슷하게 만들면 된다. <br /><code class="language-plaintext highlighter-rouge">YEAR-MONTH-DAY-title.md</code> 형식으로 파일을 만들어주면 포스트로 인식해준다.<br />파일 이름에 한글이 있으면 업로드가 안 되는데… 그냥 영문도 모른채 영문으로 작성했다.<br /></p>

<p>첫 줄을 보면 아래와 같은 부분이 있다. 필요한 부분을 수정하자.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">layout: </span><span class="n">post</span>				<span class="c1"># post에 올리기</span>
<span class="ss">title:  </span><span class="s2">"Welcome to Jekyll!"</span>		<span class="c1"># 글 제목을 "" 사이에 넣기. 이건 한글도 괜찮다.</span>
<span class="ss">date:   </span><span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">20</span> <span class="mi">17</span><span class="p">:</span><span class="mi">48</span><span class="p">:</span><span class="mi">56</span> <span class="o">+</span><span class="mi">0900</span>	<span class="c1"># 날짜. 시간은 안 넣어도 괜찮다.</span>
<span class="ss">categories: </span><span class="n">jekyll</span> <span class="n">update</span>		<span class="c1"># 카테고리. 당장은 수정하는 느낌이 안 난다.</span>
</code></pre></div></div>

<p><del>여기서 포기할걸</del></p>

<hr />

<p><br /></p>

<h2 id="5-꾸미는-방법들"><strong>5. 꾸미는 방법들</strong></h2>

<p>템플릿은 Liquid 라는 언어로 구성되어 있다고 한다.<br />그럼 이걸로 바로 만들면 되겠지만, 내 스펙으로 웹문서 작성은 너무 힘들다.<br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Infomation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1. head, body, a color 등 매우 다양한 태그를 이용하여 <strong><code class="language-plaintext highlighter-rouge">"Hello world!" 작성 가능</code></strong><br />2. 저열한 태그 이해도</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="5-1-jekyll-admin-이용하기"><strong>5-1. jekyll admin 이용하기</strong></h3>

<p><a href="https://github.com/jekyll/jekyll-admin/blob/master/README.md">jekyll admin 설명 원문</a></p>

<p>jekyll은 나같은 사람도 쓸 수 있게 무려 관리 페이지를 만들어주는 기능이 있다.<br />ruby 콘솔에 <code class="language-plaintext highlighter-rouge">gem install jekyll-admin</code> 쳐서 다운받자.<br />그 다음, 만든 폴더 내부에 파일 확장자 없이 <code class="language-plaintext highlighter-rouge">Gemfile</code>이라고만 써있는 것이 하나 있다.<br />얘를 열어서 마지막 줄에 <code class="language-plaintext highlighter-rouge">gem 'jekyll-admin', group: :jekyll_plugins</code> 를 추가한다.<br />ruby 콘솔 창에 <code class="language-plaintext highlighter-rouge">bundle install</code> 쳐주면 설치는 완료되었다.<br /></p>

<p>작동법은 다음과 같다. <br /></p>

<p>(1) 아까처럼 <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code>을 ruby 콘솔창에 쳐서 서버 작동.<br /></p>

<p>(2) <code class="language-plaintext highlighter-rouge">http://localhost:4000/admin</code> 으로 접속.</p>

<figure>
    <a href="/posts_image/jekyll_guide/jekyll_admin.JPG"><img src="/posts_image/jekyll_guide/jekyll_admin.JPG" /></a>
    <figcaption><center><b>뭔가 그럴싸한 관리페이지가 생겼다</b></center></figcaption>
</figure>

<p>글 쓰는 부분이나 페이지 만드는 부분들이 있다. 보통 블로그보단 불친절하다.<br />글은 markdown 편집기로 쓴 다음, 시간같은 메타데이터를 여기서 변경하면 좋아보인다.<br /></p>

<p><del>여기까지 하는데 5시간 넘게 걸렸는데 언제 다하나</del><br /><br /></p>

<h3 id="5-2-jekyll-theme-이용하기"><strong>5-2. jekyll theme 이용하기</strong></h3>

<p>jekyll은 <a href="http://jekyllthemes.org/">각종 테마를 제공</a>하고 있다.<br />다른 위인들께서 만든 것을 공유하는 듯하다. 마음에 드는 테마 들어가서 다운로드 받자.<br /></p>

<p>다운로드 말고 <code class="language-plaintext highlighter-rouge">Fork</code>를 통해 바로 github에 집어넣는 방법도 있다.<br />하지만, 나는 로컬에서 돌려보는 것이 목적이라 바로 다운로드 받았다.</p>

<p>압축 해제한 폴더로 ruby 콘솔로 들어간 후, 아까처럼 <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code> 치자.<br />폴더에 들어가서 <code class="language-plaintext highlighter-rouge">_config.yml</code> 파일과 다른 파일들을 수정하면 거의 호스팅 완료 단계까지 만들어진다.<br /></p>

<p>그러나, 맹점이 하나 있다. 수정이 어렵다.<br />내 스펙이 증명하듯, 수정하려면 뭘 알아야 하는데 모르니까 너무 힘들었다.<br />많이 쓰는 테마들은 맘에 안들고,<br />별로 안 쓰는 테마들은 친절한 수정 설명이 부족했다.<br /></p>

<p>결국, 내가 사용하고 싶은 테마의 기능을 만들기 위해서는 다른 사람들 github 파일이 어찌 다른지 확인하는 편이 빨라보였다.<br /><del>jupyter notebook 간단한 색깔 설정 바꾸는 것도 css 잘 몰라서 2일 걸렸는데</del><br /></p>

<p>다음을 기약하며 빠른 수면을 택했다. <br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="jekyll" /><category term="github" /><summary type="html"><![CDATA[Github 블로그 갖기 위한 여정]]></summary></entry><entry><title type="html">First test</title><link href="http://localhost:4000/hello/" rel="alternate" type="text/html" title="First test" /><published>2019-12-14T00:00:00+09:00</published><updated>2019-12-14T00:00:00+09:00</updated><id>http://localhost:4000/hello</id><content type="html" xml:base="http://localhost:4000/hello/"><![CDATA[<p>첫 문서 테스트 중.</p>

<h2 id="1-코드">1. 코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</code></pre></div></div>

<h2 id="2-일반-마크다운">2. 일반 마크다운</h2>

<!--more-->

<p><em>기울이기</em></p>

<p><strong>굵게</strong></p>

<p><code class="language-plaintext highlighter-rouge">하이라이트</code></p>

<p><strong><em><code class="language-plaintext highlighter-rouge">굵고 기울인 하이라이트</code></em></strong></p>

<p><u>밑줄</u>은 html 태그로</p>

<p><del>취소선</del></p>]]></content><author><name></name></author><category term="test" /><category term="hello" /><category term="first" /><category term="intro" /><summary type="html"><![CDATA[첫 문서 테스트 중.]]></summary></entry></feed>